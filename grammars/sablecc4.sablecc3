/* This file is part of SableCC ( http://sablecc.org ).
 *
 * See the NOTICE file distributed with this work for copyright information.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Package org.sablecc.sablecc.syntax3;

Helpers

  any = [0 .. 0xffff];

  carriage_return = 13;
  line_feed = 10;
  tab = 9;
  white_space = ' ';

  end_of_line =
    carriage_return |
    line_feed |
    carriage_return line_feed;

  decimal_digit = ['0' .. '9'];
  hexadecimal_digit = [decimal_digit + [['a' .. 'f'] + ['A' .. 'F']]];

  lower_case_letter = ['a' .. 'z'];
  upper_case_letter = ['A' .. 'Z'];

  string_character = [[32..126] - '''];

  identifier_part = lower_case_letter (lower_case_letter | decimal_digit)*;

  not_star = [any - '*'];
  not_star_slash = [any - ['/' + '*']];

  not_end_of_line = [any - [carriage_return + line_feed]];

  long_comment = '/*' not_star* ('*' (not_star_slash not_star*)?)* '*/';
  line_comment = '//' not_end_of_line* end_of_line?;

  invalid_construct_char =
    lower_case_letter |
    upper_case_letter |
    '_' |
    decimal_digit;

Tokens

  // keywords

  any_keyword = 'Any';
  associative_keyword = 'Associative';
  context_keyword = 'Context';
  dangling_keyword = 'Dangling';
  group_keyword = 'Group';
  ignored_keyword = 'Ignored';
  infinite_keyword = 'Infinite';
  inlined_keyword = 'Inlined';
  investigator_keyword = 'Investigator';
  language_keyword = 'Language';
  left_keyword = 'Left';
  lexer_keyword = 'Lexer';
  lookahead_keyword = 'Lookahead';
  no_keyword = 'No';
  over_keyword = 'Over';
  parser_keyword = 'Parser';
  priority_keyword = 'Priority';
  rejected_keyword = 'Rejected';
  right_keyword = 'Right';
  separator_keyword = 'Separator';
  shortest_keyword = 'Shortest';
  start_keyword = 'Start';
  token_keyword = 'Token';
  unary_keyword = 'Unary';

  // separators

  colon = ':';
  comma = ',';
  semicolon = ';';
  three_dots = '...';
  two_dots = '..';

  left_brace  = '{';
  right_brace = '}';

  left_bracket = '[';
  right_bracket = ']';

  left_parenthesis = '(';
  right_parenthesis = ')';

  // operators

  assign = '=';
  bar = '|';
  caret = '^';
  minus = '-';
  plus = '+';
  question_mark = '?';
  star = '*';

  // identifier, numbers, strings and character

  identifier = identifier_part ('_' identifier_part)*;

  number = decimal_digit+;

  string = ''' string_character string_character+ ''';
  character_token = ''' (string_character | ''') ''';
  empty_string = ''' ''';

  decimal_character = '#' decimal_digit+;
  hexadecimal_character = '#' ('x' | 'X') hexadecimal_digit+;

  // blanks

  blanks = (white_space | tab | end_of_line | long_comment | line_comment)+;

  // invalid constructs

  invalid_identifier = (lower_case_letter | '_') invalid_construct_char*;

  invalid_keyword = upper_case_letter invalid_construct_char*;

  invalid_number = decimal_digit invalid_construct_char*;

Ignored Tokens

  blanks;

Productions

  language =
    header? lexer? parser?;

  header =
    language_keyword [name]:identifier semicolon;

  lexer =
    lexer_keyword groups lexer_contexts;

  groups =
    default_group [named_groups]:named_group*;

  default_group =
    [named_regular_expressions]:named_regular_expression*;

  named_group =
    group_keyword [name]:identifier colon group_collection?
    [named_regular_expressions]:named_regular_expression*;

  named_regular_expression =
    [name]:identifier assign expression semicolon;

  expression =
    top_level_expression
    [additional_top_level_expressions]:additional_top_level_expression*;

  additional_top_level_expression =
    bar top_level_expression;

  top_level_expression =
    {simple}      concatenation_expression |
    {subtraction} [left_expression]:concatenation_expression minus
                  [right_expression]:concatenation_expression |
    {shortest}    shortest_keyword concatenation_expression |
    {interval}    [lower_bound_character]:character two_dots
                  [upper_bound_character]:character;

  concatenation_expression =
    [unary_expressions]:unary_expression+;

  unary_expression =
    term unary_operator?;

  term =
    {group_literal} group_literal |
    {parenthesis}  left_parenthesis expression right_parenthesis;

  unary_operator =
    {zero_or_one} question_mark |
    {many}        many_operator;

  many_operator =
    {zero_or_more} star |
    {one_or_more}  plus |
    {number}       caret [exponent]:number |
    {interval}     caret left_parenthesis [lower_bound_exponent]:number
                   two_dots [upper_bound_exponent]:number right_parenthesis |
    {at_least}     caret left_parenthesis [lower_bound_exponent]:number
                   three_dots right_parenthesis;

  lexer_contexts =
    lexer_default_context [lexer_named_contexts]:lexer_named_context*;

  lexer_default_context =
    lexer_context_body;

  lexer_named_context =
    context_keyword [name]:identifier colon lexer_context_body;

  lexer_context_body =
    tokens? ignored? rejected? lexer_priorities? lookahead?
    lexer_investigators?;

  tokens =
    token_keyword group_collection;

  ignored =
    ignored_keyword group_collection;

  rejected =
    rejected_keyword group_collection;

  group_collection =
    group_list semicolon;

  group_list =
    group_literal [additional_groups]:additional_group*;

  additional_group =
    comma group_literal;

  lexer_priorities =
    priority_keyword [lexer_priorities]:lexer_priority+;

  lexer_priority =
    [high_priority_group]:group_literal over_keyword
    [low_priority_group]:group_literal semicolon;

  lookahead =
    {no}       no_keyword lookahead_keyword semicolon |
    {infinite} infinite_keyword lookahead_keyword semicolon;

  lexer_investigators =
    [lexer_investigators]:lexer_investigator+;

  lexer_investigator =
    investigator_keyword [name]:identifier
    left_parenthesis group_literal right_parenthesis semicolon;

  group_literal =
    {name}         identifier |
    {string}       string |
    {character}    character |
    {empty_string} empty_string |
    {any}          any_keyword;

  character =
    {character}   character_token |
    {decimal}     decimal_character |
    {hexadecimal} hexadecimal_character;

  parser =
    parser_keyword start parser_contexts inlined?;

  start =
    start_lookahead? start_no_lookahead?;

  start_lookahead =
    start_keyword identifier_list semicolon;

  start_no_lookahead =
    start_keyword no_keyword lookahead_keyword identifier_list semicolon;

  parser_contexts =
    parser_default_context [parser_named_contexts]:parser_named_context*;

  parser_default_context =
    [parser_productions]:parser_production*;

  parser_named_context =
    context_keyword [name]:identifier colon
    [parser_productions]:parser_production*;

  parser_production =
    {normal}    parser_qualifier? parser_production_body
                parser_priorities? parser_investigators? |
    {selection} semantic_selection;

  parser_qualifier =
    {dangling} dangling_keyword |
    {token}    token_keyword;

  parser_production_body =
    [name]:identifier assign parser_alternatives semicolon;

  parser_alternatives =
    parser_alternative
    [additional_parser_alternatives]:additional_parser_alternative*;

  additional_parser_alternative =
    bar parser_alternative;

  parser_alternative =
    parser_alternative_name? [parser_elements]:parser_element*
    parser_dangling_element?;

  parser_alternative_name =
    left_brace identifier colon right_brace;

  parser_element =
    {normal}    parser_element_name? parser_element_body unary_operator? |
    {separated} parser_element_name? left_parenthesis
                [left_parser_element]:parser_element separator_keyword
                [right_parser_element]:parser_element
                right_parenthesis many_operator?;

  parser_dangling_element =
    dangling_keyword parser_element_name? identifier question_mark;

  parser_element_name =
    left_bracket identifier colon right_bracket;

  parser_element_body =
    {group_literal} group_literal |
    {parenthesis}   left_parenthesis parser_subalternatives
                    right_parenthesis;

  parser_subalternatives =
    parser_subalternative
    [additional_parser_subalternatives]:additional_parser_subalternative*;

  additional_parser_subalternative =
    bar parser_subalternative;

  parser_subalternative =
    [parser_elements]:parser_element*;

  parser_priorities =
    priority_keyword [parser_priorities]:parser_priority+;

  parser_priority =
    {left_associative}  left_keyword associative_keyword
                        colon identifier_list semicolon |
    {right_associative} right_keyword associative_keyword
                        colon identifier_list semicolon |
    {left_unary}        left_keyword unary_keyword
                        colon identifier_list semicolon |
    {right_unary}       right_keyword unary_keyword
                        colon identifier_list semicolon;

  parser_investigators =
    [parser_investigators]:parser_investigator+;

  parser_investigator =
    investigator_keyword [name]:identifier
    left_parenthesis identifier_list? right_parenthesis semicolon;

  semantic_selection =
    long_identifier_list assign [name]:identifier
    left_parenthesis identifier right_parenthesis semicolon;

  long_identifier_list =
    identifier [additional_identifiers]:additional_identifier+;

  inlined =
    inlined_keyword identifier_list semicolon;

  identifier_list =
    identifier [additional_identifiers]:additional_identifier*;

  additional_identifier =
    comma identifier;
