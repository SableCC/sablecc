/* This file is part of SableCC ( http://sablecc.org ).
 *
 * See the NOTICE file distributed with this work for copyright information.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Package org.sablecc.sablecc.syntax3;

Helpers

  any = [0 .. 0xffff];

  carriage_return = 13;
  line_feed = 10;
  tab = 9;
  white_space = ' ';

  end_of_line =
    carriage_return |
    line_feed |
    carriage_return line_feed;

  decimal_digit = ['0' .. '9'];
  hexadecimal_digit = [decimal_digit + [['a' .. 'f'] + ['A' .. 'F']]];

  lower_case_letter = ['a' .. 'z'];
  upper_case_letter = ['A' .. 'Z'];

  string_character = [[32..126] - '''];

  identifier_part = lower_case_letter (lower_case_letter | decimal_digit)*;

  not_star = [any - '*'];
  not_star_slash = [any - ['/' + '*']];

  not_end_of_line = [any - [carriage_return + line_feed]];

  long_comment = '/*' not_star* ('*' (not_star_slash not_star*)?)* '*/';
  line_comment = '//' not_end_of_line* end_of_line?;

  invalid_construct_char =
    lower_case_letter |
    upper_case_letter |
    '_' |
    decimal_digit;

Tokens

  // keywords

  alternative_keyword = 'Alternative';
  any_keyword = 'Any';
  associative_keyword = 'Associative';
  context_keyword = 'Context';
  dangling_keyword = 'Dangling';
  difference_keyword = 'Difference';
  end_keyword = 'End';
  exclusion_keyword = 'Exclusion';
  group_keyword = 'Group';
  ignored_keyword = 'Ignored';
  infinite_keyword = 'Infinite';
  inlined_keyword = 'Inlined';
  intersection_keyword = 'Intersection';
  investigator_keyword = 'Investigator';
  language_keyword = 'Language';
  left_keyword = 'Left';
  lexer_keyword = 'Lexer';
  longest_keyword = 'Longest';
  lookahead_keyword = 'Lookahead';
  no_keyword = 'No';
  not_keyword = 'Not';
  null_keyword = 'Null';
  over_keyword = 'Over';
  parser_keyword = 'Parser';
  priority_keyword = 'Priority';
  production_keyword = 'Production';
  rejected_keyword = 'Rejected';
  right_keyword = 'Right';
  separator_keyword = 'Separator';
  shortest_keyword = 'Shortest';
  start_keyword = 'Start';
  token_keyword = 'Token';
  transformation_keyword = 'Transformation';
  tree_keyword = 'Tree';
  unary_keyword = 'Unary';

  // separators

  colon = ':';
  comma = ',';
  dot = '.';
  semicolon = ';';
  three_dots = '...';
  two_dots = '..';

  left_brace  = '{';
  right_brace = '}';

  left_bracket = '[';
  right_bracket = ']';

  left_parenthesis = '(';
  right_parenthesis = ')';

  // operators

  arrow = '->';
  assign = '=';
  bar = '|';
  caret = '^';
  plus = '+';
  question_mark = '?';
  star = '*';

  // identifier, numbers, strings and character

  identifier = identifier_part ('_' identifier_part)*;

  number = decimal_digit+;

  string = ''' string_character string_character+ ''';
  character_token = ''' (string_character | ''') ''';
  empty_string = ''' ''';

  decimal_character = '#' decimal_digit+;
  hexadecimal_character = '#' ('x' | 'X') hexadecimal_digit+;

  // blanks

  blanks = (white_space | tab | end_of_line | long_comment | line_comment)+;

  // invalid constructs

  invalid_identifier = (lower_case_letter | '_') invalid_construct_char*;

  invalid_keyword = upper_case_letter invalid_construct_char*;

  invalid_number = decimal_digit invalid_construct_char*;

Ignored Tokens

  blanks;

Productions

  language =
    header? lexer? parser? transformation? tree?;

  header =
    language_keyword [name]:identifier semicolon;

  lexer =
    lexer_keyword infinite_lookahead? groups lexer_contexts;

  groups =
    default_group [named_groups]:named_group*;

  default_group =
    [named_regular_expressions]:named_regular_expression*;

  named_group =
    group_keyword [name]:identifier colon group_collection?
    [named_regular_expressions]:named_regular_expression*;

  named_regular_expression =
    [name]:identifier assign expression semicolon;

  expression =
    top_level_expression
    [additional_top_level_expressions]:additional_top_level_expression*;

  additional_top_level_expression =
    bar top_level_expression;

  top_level_expression =
    {simple}       concatenation_expression |
    {interval}     [lower_bound_character]:character two_dots
                   [upper_bound_character]:character |
    {lookahead}    [left_expression]:concatenation_expression lookahead_keyword
                   not_keyword? [right_expression]:concatenation_expression?
                   end_keyword? |
    {shortest}     shortest_keyword concatenation_expression |
    {longest}      longest_keyword concatenation_expression |
    {exclusion}    [left_expression]:concatenation_expression exclusion_keyword
                   [right_expression]:concatenation_expression |
    {difference}   [left_expression]:concatenation_expression
                   difference_keyword
                   [right_expression]:concatenation_expression |
    {intersection} [left_expression]:concatenation_expression
                   intersection_keyword
                   [right_expression]:concatenation_expression;

  concatenation_expression =
    [unary_expressions]:unary_expression+;

  unary_expression =
    term unary_operator?;

  term =
    {group_literal} group_literal |
    {parenthesis}   left_parenthesis expression right_parenthesis;

  unary_operator =
    {zero_or_one} question_mark |
    {many}        many_operator;

  many_operator =
    {zero_or_more} star |
    {one_or_more}  plus |
    {number}       caret [exponent]:number |
    {interval}     caret left_parenthesis [lower_bound_exponent]:number
                   two_dots [upper_bound_exponent]:number right_parenthesis |
    {at_least}     caret left_parenthesis [lower_bound_exponent]:number
                   three_dots right_parenthesis;

  lexer_contexts =
    lexer_default_context [lexer_named_contexts]:lexer_named_context*;

  lexer_default_context =
    lexer_context_body;

  lexer_named_context =
    context_keyword [name]:identifier colon lexer_context_body;

  lexer_context_body =
    tokens? ignored? rejected? lexer_priorities? lexer_investigators?;

  tokens =
    token_keyword group_collection;

  ignored =
    ignored_keyword group_collection;

  rejected =
    rejected_keyword group_collection;

  group_collection =
    group_list semicolon;

  group_list =
    group_literal [additional_groups]:additional_group*;

  additional_group =
    comma group_literal;

  lexer_priorities =
    priority_keyword [lexer_priorities]:lexer_priority+;

  lexer_priority =
    [high_priority_group]:group_literal over_keyword
    [low_priority_group]:group_literal semicolon;

  infinite_lookahead =
    infinite_keyword lookahead_keyword semicolon;

  lexer_investigators =
    [lexer_investigators]:lexer_investigator+;

  lexer_investigator =
    investigator_keyword [name]:identifier
    left_parenthesis group_literal right_parenthesis semicolon;

  group_literal =
    {name}         identifier |
    {string}       string |
    {character}    character |
    {empty_string} empty_string |
    {any}          any_keyword;

  character =
    {character}   character_token |
    {decimal}     decimal_character |
    {hexadecimal} hexadecimal_character;

  parser =
    parser_keyword start parser_contexts inlined?;

  start =
    normal_start? start_no_end?;

  normal_start =
    start_keyword identifier_list semicolon;

  start_no_end =
    start_keyword no_keyword end_keyword identifier_list semicolon;

  parser_contexts =
    parser_default_context [parser_named_contexts]:parser_named_context*;

  parser_default_context =
    [parser_productions]:parser_production*;

  parser_named_context =
    context_keyword [name]:identifier colon
    [parser_productions]:parser_production*;

  parser_production =
    {normal}    parser_qualifier? parser_production_body
                parser_priorities? parser_investigators? |
    {selection} semantic_selection;

  parser_qualifier =
    {dangling} dangling_keyword |
    {token}    token_keyword;

  parser_production_body =
    [name]:identifier assign parser_alternatives semicolon;

  parser_alternatives =
    parser_alternative
    [additional_parser_alternatives]:additional_parser_alternative*;

  additional_parser_alternative =
    bar parser_alternative;

  parser_alternative =
    alternative_name? [elements]:element* parser_dangling_element?;

  alternative_name =
    left_brace identifier colon right_brace;

  parser_dangling_element =
    dangling_keyword element_name? identifier question_mark;

  element =
    {normal}    element_name? element_body unary_operator? |
    {separated} element_name? left_parenthesis [left_element]:element
                separator_keyword [right_element]:element right_parenthesis
                many_operator;

  element_name =
    left_bracket identifier colon right_bracket;

  element_body =
    {group_literal} group_literal |
    {parenthesis}   left_parenthesis subalternatives right_parenthesis;

  subalternatives =
    subalternative [additional_subalternatives]:additional_subalternative*;

  additional_subalternative =
    bar subalternative;

  subalternative =
    [elements]:element*;

  parser_priorities =
    priority_keyword [parser_priorities]:parser_priority+;

  parser_priority =
    {left_associative}  left_keyword associative_keyword identifier_list
                        semicolon |
    {right_associative} right_keyword associative_keyword identifier_list
                        semicolon |
    {left_unary}        left_keyword unary_keyword identifier_list semicolon |
    {right_unary}       right_keyword unary_keyword identifier_list semicolon;

  parser_investigators =
    [parser_investigators]:parser_investigator+;

  parser_investigator =
    investigator_keyword [name]:identifier
    left_parenthesis identifier_list? right_parenthesis semicolon;

  semantic_selection =
    long_identifier_list assign [name]:identifier
    left_parenthesis identifier right_parenthesis semicolon;

  long_identifier_list =
    identifier [additional_identifiers]:additional_identifier+;

  inlined =
    inlined_keyword identifier_list semicolon;

  identifier_list =
    identifier [additional_identifiers]:additional_identifier*;

  additional_identifier =
    comma identifier;

  transformation =
    transformation_keyword
    production_transformations? alternative_transformations?;

  production_transformations =
    production_keyword [production_transformations]:production_transformation*;

  production_transformation =
    [production_name]:identifier arrow element_list? semicolon;

  element_list =
    element [additional_elements]:additional_element*;

  additional_element =
    comma element;

  alternative_transformations =
    alternative_keyword
    [alternative_transformations]:alternative_transformation*;

  alternative_transformation =
    alternative_reference arrow transformation_element_list? semicolon;

  alternative_reference =
    {unnamed} [production_name]:identifier |
    {named}   [production_name]:identifier dot [alternative_name]:identifier;

  transformation_element_list =
    transformation_element
    [additional_transformation_elements]:additional_transformation_element*;

  additional_transformation_element =
    comma transformation_element;

  transformation_element =
    {null}      null_keyword |
    {reference} element_reference |
    {new}       alternative_reference left_parenthesis
                transformation_element_list? right_parenthesis |
    {list}      left_bracket transformation_element_list? right_bracket |
    {tuple}     left_parenthesis transformation_element_list?
                right_parenthesis;

  element_reference =
    {direct} [name]:identifier |
    {nested} [name]:identifier dot [nested_name]:identifier;

  tree =
    tree_keyword [tree_productions]:tree_production*;

  tree_production =
    [name]:identifier assign tree_alternatives semicolon;

  tree_alternatives =
    tree_alternative
    [additional_tree_alternatives]:additional_tree_alternative*;

  additional_tree_alternative =
    bar tree_alternative;

  tree_alternative =
    alternative_name? [elements]:element*;
