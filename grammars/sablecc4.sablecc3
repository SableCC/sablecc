/* This file is part of SableCC ( http://sablecc.org ).
 *
 * See the NOTICE file distributed with this work for copyright information.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Package org.sablecc.sablecc.syntax3;

Helpers

  any = [0 .. 0xffff];

  carriage_return = 13;
  line_feed       = 10;
  tab             = 9;
  white_space     = ' ';

  end_of_line     =
    carriage_return |
    line_feed |
    carriage_return line_feed;

  decimal_digit     = ['0' .. '9'];
  hexadecimal_digit = [decimal_digit + [['a' .. 'f'] + ['A' .. 'F']]];
  lower_case_letter = ['a' .. 'z'];
  upper_case_letter = ['A' .. 'Z'];

  string_character  = [[32..126] - '''];

  identifier_part = lower_case_letter (lower_case_letter | decimal_digit)*;

  not_star       = [any - '*'];
  not_star_slash = [any - ['/' + '*']];

  not_end_of_line = [any - [carriage_return + line_feed]];

  long_comment = '/*' not_star* ('*' (not_star_slash not_star*)?)* '*/';
  line_comment = '//' not_end_of_line* end_of_line?;

  invalid_construct_char = lower_case_letter | upper_case_letter | '_' | decimal_digit;

Tokens

  // keywords

  any_keyword           = 'Any';
  context_keyword       = 'Context';
  group_keyword         = 'Group';
  ignored_keyword       = 'Ignored';
  infinite_keyword      = 'Infinite';
  investigators_keyword = 'Investigators';
  language_keyword      = 'Language';
  lookahead_keyword     = 'Lookahead';
  lexer_keyword         = 'Lexer';
  no_keyword            = 'No';
  over_keyword          = 'Over';
  priorities_keyword    = 'Priorities';
  shortest_keyword      = 'Shortest';
  tokens_keyword        = 'Tokens';

  // separators

  colon      = ':';
  comma      = ',';
  semicolon  = ';';
  three_dots = '...';
  two_dots   = '..';

  left_parenthesis  = '(';
  right_parenthesis = ')';

  // operators

  assign        = '=';
  bar           = '|';
  caret         = '^';
  minus         = '-';
  plus          = '+';
  question_mark = '?';
  star          = '*';

  // identifier, numbers, strings and character

  identifier = identifier_part ('_' identifier_part)*;

  number = decimal_digit+;

  decimal_character     = '#' decimal_digit+;
  hexadecimal_character = '#' ('x' | 'X') hexadecimal_digit+;

  empty_string    = ''' ''';
  character_token = ''' (string_character | ''') ''';
  string          = ''' string_character string_character+ ''';

  // blanks

  blanks = (white_space | tab | end_of_line | long_comment | line_comment)+;

  // invalid constructs

  invalid_identifier = (lower_case_letter | '_') invalid_construct_char*;

  invalid_keyword = upper_case_letter invalid_construct_char*;

  invalid_number = decimal_digit invalid_construct_char*;

Ignored Tokens

  blanks;

Productions

  // language

  language =
    language_header? lexer?;

  language_header =
    language_keyword [name]:identifier;

  // lexer

  lexer =
    lexer_keyword helpers tokens? ignored? priorities? lookahead? investigators? context*;

  // helpers

  helpers =
    [helpers]:helper* [groups]:group*;

  group =
    group_keyword [name]:identifier group_body;

  group_body =
    {helpers} [helpers]:helper+ |
    {list}    identifier_list semicolon;

  helper =
    [name]:identifier assign regular_expression semicolon;

  // tokens

  tokens =
    tokens_keyword identifier_list semicolon;

  // ignored

  ignored =
    ignored_keyword identifier_list semicolon;

  // priorities

  priorities =
    priorities_keyword [priorities]:priority+;

  priority =
    [high_priority]:identifier over_keyword [low_priority]:identifier semicolon;

  // lookahead

  lookahead =
    {no}       no_keyword lookahead_keyword |
    {infinite} infinite_keyword lookahead_keyword;

  // investigators

  investigators =
    investigators_keyword [investigators]:investigator+;

  investigator =
    [name]:identifier left_parenthesis right_parenthesis colon identifier_list semicolon;

  // context

  context =
    context_keyword [name]:identifier tokens? ignored? priorities? lookahead? investigators?;

  // regular expression

  regular_expression =
    expression [additional_expressions]:additional_expression*;

  additional_expression =
    bar expression;

  expression =
    {concat}           concat_expression |
    {interval}         [lower_bound]:character two_dots [upper_bound]:character |
    {shortest}         shortest_keyword concat_expression |
    {subtract}         [left]:concat_expression minus [right]:concat_expression;

  concat_expression =
    {simple} unary_expression |
    {normal} concat_expression unary_expression;

  unary_expression =
    {simple}       term |
    {zero_or_one}  term question_mark |
    {zero_or_more} term star |
    {one_or_more}  term plus |
    {exponent}     term caret [times]:number |
    {range}        term caret left_parenthesis [from]:number two_dots [to]:number right_parenthesis |
    {at_least}     term caret left_parenthesis [times]:number three_dots right_parenthesis;

  term =
    {parenthesized} left_parenthesis regular_expression right_parenthesis |
    {string}        string |
    {empty_string}  empty_string |
    {character}     character |
    {any}           any_keyword |
    {helper}        identifier;

  character =
    {character}   character_token |
    {decimal}     decimal_character |
    {hexadecimal} hexadecimal_character;

  // token collection

  identifier_list =
    identifier [additional_identifiers]:additional_identifier*;

  additional_identifier =
    comma identifier;
