/* This file is part of SableCC ( http://sablecc.org ).
 *
 * See the NOTICE file distributed with this work for copyright information.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Package org.sablecc.sablecc.syntax3;

Helpers

  any = [0 .. 0xffff];

  carriage_return = 13;
  line_feed       = 10;
  tab             = 9;
  white_space     = ' ';

  end_of_line     =
    carriage_return |
    line_feed |
    carriage_return line_feed;

  decimal_digit     = ['0' .. '9'];
  hexadecimal_digit = [decimal_digit + [['a' .. 'f'] + ['A' .. 'F']]];
  lower_case_letter = ['a' .. 'z'];
  upper_case_letter = ['A' .. 'Z'];

  string_character  = [[32..126] - '''];

  identifier_part = lower_case_letter (lower_case_letter | decimal_digit)*;

  not_star       = [any - '*'];
  not_star_slash = [any - ['/' + '*']];

  not_end_of_line = [any - [carriage_return + line_feed]];

  long_comment = '/*' not_star* ('*' (not_star_slash not_star*)?)* '*/';
  line_comment = '//' not_end_of_line* end_of_line?;

  invalid_construct_char = lower_case_letter | upper_case_letter | '_' | decimal_digit;

Tokens

  // keywords

  any_keyword          = 'Any';
  associative_keyword  = 'Associative';
  context_keyword      = 'Context';
  dangling_keyword     = 'Dangling';
  group_keyword        = 'Group';
  ignored_keyword      = 'Ignored';
  infinite_keyword     = 'Infinite';
  inline_keyword       = 'Inline';
  investigator_keyword = 'Investigator';
  language_keyword     = 'Language';
  left_keyword         = 'Left';
  lookahead_keyword    = 'Lookahead';
  lexer_keyword        = 'Lexer';
  no_keyword           = 'No';
  over_keyword         = 'Over';
  parser_keyword       = 'Parser';
  priorities_keyword   = 'Priorities';
  right_keyword        = 'Right';
  shortest_keyword     = 'Shortest';
  start_keyword        = 'Start';
  token_keyword        = 'Token';
  tokens_keyword       = 'Tokens';
  unary_keyword        = 'Unary';

  // separators

  colon      = ':';
  comma      = ',';
  semicolon  = ';';
  three_dots = '...';
  two_dots   = '..';

  left_parenthesis  = '(';
  right_parenthesis = ')';

  left_brace  = '{';
  right_brace = '}';

  left_bracket  = '[';
  right_bracket = ']';

  // operators

  assign        = '=';
  bar           = '|';
  caret         = '^';
  minus         = '-';
  plus          = '+';
  question_mark = '?';
  star          = '*';

  // identifier, numbers, strings and character

  identifier = identifier_part ('_' identifier_part)*;

  number = decimal_digit+;

  decimal_character     = '#' decimal_digit+;
  hexadecimal_character = '#' ('x' | 'X') hexadecimal_digit+;

  empty_string    = ''' ''';
  character_token = ''' (string_character | ''') ''';
  string          = ''' string_character string_character+ ''';

  // blanks

  blanks = (white_space | tab | end_of_line | long_comment | line_comment)+;

  // invalid constructs

  invalid_identifier = (lower_case_letter | '_') invalid_construct_char*;

  invalid_keyword = upper_case_letter invalid_construct_char*;

  invalid_number = decimal_digit invalid_construct_char*;

Ignored Tokens

  blanks;

Productions

  // language

  language =
    language_header? lexer? parser?;

  language_header =
    language_keyword [name]:identifier;

  // lexer

  lexer =
    lexer_keyword helpers tokens? ignored? priorities? lookahead? investigators? context*;

  // helpers

  helpers =
    [helpers]:helper* [groups]:group*;

  group =
    group_keyword [name]:identifier group_body;

  group_body =
    {helpers} [helpers]:helper+ |
    {list}    identifier_list semicolon;

  helper =
    [name]:identifier assign regular_expression semicolon;

  // tokens

  tokens =
    tokens_keyword identifier_list semicolon;

  // ignored

  ignored =
    ignored_keyword identifier_list semicolon;

  // priorities

  priorities =
    priorities_keyword [priorities]:priority+;

  priority =
    [high_priority]:identifier over_keyword [low_priority]:identifier semicolon;

  // lookahead

  lookahead =
    {no}       no_keyword lookahead_keyword |
    {infinite} infinite_keyword lookahead_keyword;

  // investigators

  investigators =
    [investigators]:investigator+;

  investigator =
    investigator_keyword [name]:identifier left_parenthesis right_parenthesis identifier_list semicolon;

  // context

  context =
    context_keyword [name]:identifier tokens? ignored? priorities? lookahead? investigators?;

  // regular expression

  regular_expression =
    expression [additional_expressions]:additional_expression*;

  additional_expression =
    bar expression;

  expression =
    {concat}           concat_expression |
    {interval}         [lower_bound]:character two_dots [upper_bound]:character |
    {shortest}         shortest_keyword concat_expression |
    {subtract}         [left]:concat_expression minus [right]:concat_expression;

  concat_expression =
    {simple} unary_expression |
    {normal} concat_expression unary_expression;

  unary_expression =
    term unary_op?;

  unary_op =
    {zero_or_one}  question_mark |
    {zero_or_more} star |
    {one_or_more}  plus |
    {exponent}     caret [times]:number |
    {range}        caret left_parenthesis [from]:number two_dots [to]:number right_parenthesis |
    {at_least}     caret left_parenthesis [times]:number three_dots right_parenthesis;

  term =
    {parenthesized} left_parenthesis regular_expression right_parenthesis |
    {string}        string |
    {empty_string}  empty_string |
    {character}     character |
    {any}           any_keyword |
    {helper}        identifier;

  character =
    {character}   character_token |
    {decimal}     decimal_character |
    {hexadecimal} hexadecimal_character;

  // identifier list

  identifier_list =
    identifier [additional_identifiers]:additional_identifier*;

  additional_identifier =
    comma identifier;

  // parser

  parser =
    parser_keyword start? start_no_lookahead? [productions]:production* inline?;

  // start

  start =
    start_keyword identifier_list semicolon;

  // start no lookahead

  start_no_lookahead =
    start_keyword no_keyword lookahead_keyword identifier_list semicolon;

  // production

  production =
    production_body parser_priorities? parser_investigators?;

  production_body =
    {normal}    identifier assign alternatives semicolon |
    {dangling}  dangling_keyword identifier assign alternatives semicolon |
    {selection} identifier [additional_identifiers]:additional_identifier+ colon [name]:identifier left_parenthesis right_parenthesis assign unnamed_alternative semicolon |
    {token}     token_keyword identifier assign unnamed_alternative semicolon;

  alternatives =
    alternative [additional_alternatives]:additional_alternative*;

  additional_alternative =
    bar alternative;

  unnamed_alternatives =
    unnamed_alternative [additional_unnamed_alternatives]:additional_unnamed_alternative*;

  additional_unnamed_alternative =
    bar unnamed_alternative;

  // alternative

  alternative =
    alternative_name? [elements]:element* dangling_element?;

  unnamed_alternative =
    [elements]:element* dangling_element?;

  alternative_name =
    left_brace identifier right_brace;

  // element

  element =
    element_name? element_body unary_op?;

  dangling_element =
    dangling_keyword element_name? identifier question_mark;

  element_name =
    left_bracket identifier right_bracket colon;

  element_body =
    {simple}  identifier |
    {complex} left_parenthesis unnamed_alternatives right_parenthesis;

  // parser priorities

  parser_priorities =
    priorities_keyword [parser_priorities]:parser_priority+;

  parser_priority =
    {left_associative}  left_keyword associative_keyword colon identifier_list semicolon |
    {right_associative} right_keyword associative_keyword colon identifier_list semicolon |
    {left_unary}        left_keyword unary_keyword colon identifier_list semicolon |
    {right_unary}       right_keyword unary_keyword colon identifier_list semicolon;

  // parser investigators

  parser_investigators =
    [parser_investigators]:parser_investigator+;

  parser_investigator =
    investigator_keyword [name]:identifier left_parenthesis [args]:identifier_list? right_parenthesis identifier_list semicolon;

  // inline

  inline =
    inline_keyword identifier_list semicolon;
