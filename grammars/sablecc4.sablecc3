/* This file is part of SableCC ( http://sablecc.org ).
 *
 * See the NOTICE file distributed with this work for copyright information.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Package org.sablecc.sablecc.syntax3;

Helpers

  any = [0 .. 0xffff];

  carriage_return = 13;
  line_feed       = 10;
  tab             = 9;
  white_space     = ' ';

  end_of_line = carriage_return | line_feed | carriage_return line_feed;

  decimal_digit     = ['0' .. '9'];
  hexadecimal_digit = [decimal_digit + [['a' .. 'f'] + ['A' .. 'F']]];

  lower_case_letter = ['a' .. 'z'];
  upper_case_letter = ['A' .. 'Z'];

  string_character  = [[32..126] - '''];

  identifier_part = lower_case_letter (lower_case_letter | decimal_digit)*;

  not_star       = [any - '*'];
  not_star_slash = [any - ['/' + '*']];

  not_end_of_line = [any - [carriage_return + line_feed]];

  long_comment = '/*' not_star* ('*' (not_star_slash not_star*)?)* '*/';
  line_comment = '//' not_end_of_line* end_of_line?;

  invalid_construct_char = lower_case_letter | upper_case_letter | '_' | decimal_digit;

Tokens

  // keywords

  any_keyword          = 'Any';
  associative_keyword  = 'Associative';
  context_keyword      = 'Context';
  dangling_keyword     = 'Dangling';
  group_keyword        = 'Group';
  ignored_keyword      = 'Ignored';
  infinite_keyword     = 'Infinite';
  inlined_keyword      = 'Inlined';
  investigator_keyword = 'Investigator';
  language_keyword     = 'Language';
  left_keyword         = 'Left';
  lexer_keyword        = 'Lexer';
  lookahead_keyword    = 'Lookahead';
  no_keyword           = 'No';
  over_keyword         = 'Over';
  parser_keyword       = 'Parser';
  priority_keyword     = 'Priority';
  rejected_keyword     = 'Rejected';
  right_keyword        = 'Right';
  separator_keyword    = 'Separator';
  shortest_keyword     = 'Shortest';
  start_keyword        = 'Start';
  token_keyword        = 'Token';
  unary_keyword        = 'Unary';

  // separators

  colon      = ':';
  comma      = ',';
  semicolon  = ';';
  three_dots = '...';
  two_dots   = '..';

  left_brace  = '{';
  right_brace = '}';

  left_bracket  = '[';
  right_bracket = ']';

  left_parenthesis  = '(';
  right_parenthesis = ')';

  // operators

  assign        = '=';
  bar           = '|';
  caret         = '^';
  minus         = '-';
  plus          = '+';
  question_mark = '?';
  star          = '*';

  // identifier, numbers, strings and character

  identifier = identifier_part ('_' identifier_part)*;

  number = decimal_digit+;

  string          = ''' string_character string_character+ ''';
  character_token = ''' (string_character | ''') ''';
  empty_string    = ''' ''';

  decimal_character     = '#' decimal_digit+;
  hexadecimal_character = '#' ('x' | 'X') hexadecimal_digit+;

  // blanks

  blanks = (white_space | tab | end_of_line | long_comment | line_comment)+;

  // invalid constructs

  invalid_identifier = (lower_case_letter | '_') invalid_construct_char*;

  invalid_keyword = upper_case_letter invalid_construct_char*;

  invalid_number = decimal_digit invalid_construct_char*;

Ignored Tokens

  blanks;

Productions

  language =
    header? lexer? parser?;

  header =
    language_keyword [name]:identifier semicolon;

  lexer =
    lexer_keyword groups contexts;

  groups =
    default_group [named_groups]:named_group*;

  default_group =
    [regular_expressions]:regular_expression*;

  named_group =
    group_keyword [name]:identifier colon group_collection? [regular_expressions]:regular_expression*;

  regular_expression =
    [name]:identifier assign expression semicolon;

  expression =
    top_level_expression [additional_top_level_expressions]:additional_top_level_expression*;

  additional_top_level_expression =
    bar top_level_expression;

  top_level_expression =
    {simple}      concatenation_expression |
    {subtraction} [left_expression]:concatenation_expression minus [right_expression]:concatenation_expression |
    {shortest}    shortest_keyword concatenation_expression |
    {interval}    [lower_bound_character]:character two_dots [upper_bound_character]:character;

  concatenation_expression =
    [unary_expressions]:unary_expression+;

  unary_expression =
    term unary_operator?;

  term =
    {name}         identifier |
    {string}       string |
    {character}    character_token |
    {empty_string} empty_string |
    {any}          any_keyword |
    {decimal}      decimal_character |
    {hexadecimal}  hexadecimal_character |
    {parenthesis}  left_parenthesis expression right_parenthesis;

  unary_operator =
    {zero_or_more} star |
    {zero_or_one}  question_mark |
    {one_or_more}  plus |
    {exponent}     caret [exponent]:number |
    {interval}     caret left_parenthesis [lower_bound_exponent]:number two_dots [upper_bound_exponent]:number right_parenthesis |
    {at_least}     caret left_parenthesis [lower_bound_exponent]:number three_dots right_parenthesis;

  character =
    {character}   character_token |
    {decimal}     decimal_character |
    {hexadecimal} hexadecimal_character;

  contexts =
    default_context [named_contexts]:named_context*;

  default_context =
    context_body;

  named_context =
    context_keyword [name]:identifier colon context_body;

  context_body =
    tokens? ignored? rejected? priorities? lookahead? investigators?;

  tokens =
    token_keyword group_collection;

  ignored =
    ignored_keyword group_collection;

  rejected =
    rejected_keyword group_collection;

  group_collection =
    group_list semicolon;

  group_list =
    group [additional_groups]:additional_group*;

  additional_group =
    comma group;

  priorities =
    priority_keyword [priorities]:priority+;

  priority =
    [high_priority_group]:group over_keyword [low_priority_group]:group semicolon;

  group =
    {name}         identifier |
    {string}       string |
    {character}    character_token |
    {empty_string} empty_string |
    {any}          any_keyword;

  lookahead =
    {no}       no_keyword lookahead_keyword semicolon |
    {infinite} infinite_keyword lookahead_keyword semicolon;

  investigators =
    [investigators]:investigator+;

  investigator =
    investigator_keyword [name]:identifier left_parenthesis identifier right_parenthesis semicolon;

  parser =
    parser_keyword start parser_contexts inlined?;

  start =
    start_lookahead? start_no_lookahead?;

  start_lookahead =
    start_keyword identifier_list semicolon;

  start_no_lookahead =
    start_keyword no_keyword lookahead_keyword identifier_list semicolon;

  parser_contexts =
    default_parser_context [named_parser_contexts]:named_parser_context*;

  default_parser_context =
    [productions]:production*;

  named_parser_context =
    context_keyword [name]:identifier colon [productions]:production*;

  production =
    {normal}    qualifier? production_body parser_priorities? parser_investigators? |
    {selection} semantic_selection;

  qualifier =
    {dangling} dangling_keyword |
    {token}    token_keyword;

  production_body =
    identifier assign alternatives semicolon;

  alternatives =
    alternative [additional_alternatives]:additional_alternative*;

  additional_alternative =
    bar alternative;

  alternative =
    {normal}    alternative_name? [elements]:element* dangling_element? |
    {separated} alternative_name? element_name? element_body exponent_operator separator_keyword [elements]:element*;

  alternative_name =
    left_brace identifier right_brace;

  element =
    element_name? element_body unary_operator?;

  dangling_element =
    dangling_keyword element_name? identifier question_mark;

  element_name =
    left_bracket identifier colon right_bracket;

  element_body =
    {name}         identifier |
    {string}       string |
    {character}    character_token |
    {empty_string} empty_string |
    {any}          any_keyword |
    {parenthesis}  left_parenthesis element_alternatives right_parenthesis;

  element_alternatives =
    element_alternative [additional_element_alternatives]:additional_element_alternative*;

  additional_element_alternative =
    bar element_alternative;

  element_alternative =
    {normal}    [elements]:element* |
    {separated} element_name? element_body exponent_operator separator_keyword [elements]:element*;

  exponent_operator =
    {zero_or_more} star |
    {one_or_more}  plus |
    {exponent}     caret [exponent]:number |
    {interval}     caret left_parenthesis [lower_bound_exponent]:number two_dots [upper_bound_exponent]:number right_parenthesis |
    {at_least}     caret left_parenthesis [lower_bound_exponent]:number three_dots right_parenthesis;

  parser_priorities =
    priority_keyword [parser_priorities]:parser_priority+;

  parser_priority =
    {left_associative}  left_keyword associative_keyword colon identifier_list semicolon |
    {right_associative} right_keyword associative_keyword colon identifier_list semicolon |
    {left_unary}        left_keyword unary_keyword colon identifier_list semicolon |
    {right_unary}       right_keyword unary_keyword colon identifier_list semicolon;

  parser_investigators =
    [parser_investigators]:parser_investigator+;

  parser_investigator =
    investigator_keyword [name]:identifier left_parenthesis identifier_list? right_parenthesis semicolon;

  semantic_selection =
    long_identifier_list assign [name]:identifier left_parenthesis identifier right_parenthesis semicolon;

  long_identifier_list =
    identifier [additional_identifiers]:additional_identifier+;

  inlined =
    inlined_keyword identifier_list semicolon;

  identifier_list =
    identifier [additional_identifiers]:additional_identifier*;

  additional_identifier =
    comma identifier;
