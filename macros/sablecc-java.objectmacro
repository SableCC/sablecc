$comment$
This file is part of SableCC ( http://sablecc.org ).

See the NOTICE file distributed with this work for copyright information.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
$end$

$comment: ========== header ========== $

$text: header $
/* This file was generated by SableCC ( http://sablecc.org ). */
$end: header $

$comment: ========== default_package ========== $

$macro: default_package(language_name) $
package $language_name;
$end: default_package $

$comment: ========== specified_package ========== $

$macro: specified_package(language_name, package) $
package $package.$language_name;
$end: specified_package $

$comment: ========== node ========== $

$macro: node $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public abstract class Node {

  public abstract Type getType();

  public static enum Type {
$macro: node_type_enum_entry(name) $
    T_$name,
$end: node_type_enum_entry $
    TEnd,
    TAnonymous;
  }

  public abstract String getText();
  public abstract int getLine();
  public abstract int getPos();

  @Override
  public String toString() {
    return "\\"" + getText() + "\\"@(" + getLine() + "," + getPos() + ")";
  }

  abstract InternalType getInternalType();

  static enum InternalType {
$macro: node_internal_type_enum_entry(name) $
    T_$name,
$end: node_internal_type_enum_entry $
    TEnd;
  }
}
$end: node $

$comment: ========== token ========== $

$macro: token $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public abstract class Token
    extends Node {

  private final String text;
  private final int line;
  private final int pos;

  Token(String text, int line, int pos) {
    this.text = text;
    this.line = line;
    this.pos = pos;
  }

  @Override
  public String getText() {
    return this.text;
  }

  @Override
  public int getLine() {
    return this.line;
  }

  @Override
  public int getPos() {
    return this.pos;
  }
}
$end: token $

$comment: ========== custom_token ========== $

$macro: custom_token(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class N$name
    extends Token {

  N$name(String text, int line, int pos) {
    super(text, line, pos);
  }

  @Override
  public Type getType() {
    return Type.T_$name;
  }

  @Override
  InternalType getInternalType() {
    return InternalType.T_$name;
  }
}
$end: custom_token $

$comment: ========== anonymous_token ========== $

$macro: anonymous_token(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class N$name
    extends Token {

  N$name(String text, int line, int pos) {
    super(text, line, pos);
  }

  @Override
  public Type getType() {
    return Type.TAnonymous;
  }

  @Override
  InternalType getInternalType() {
    return InternalType.T_$name;
  }
}
$end: anonymous_token $

$comment: ========== lexer ========== $

$macro: lexer $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.io.*;

public class Lexer {

  private final BufferedReader br;
  private final StringBuilder buffer = new StringBuilder();
  private boolean eof;
  private int line = 1;
  private int pos = 1;
  private boolean last_is_cr;
  private StringBuilder sb;
  private int acceptLine;
  private int acceptPos;
  private int current_sb_length;
  private boolean sb_contains_eof;
$macro: marker_declaration(name) $
  private int marker$name;
$end: marker_declaration $

$macro: set_marker_declaration(name) $
  void setMarker$name() {
    this.marker$name = this.current_sb_length;
  }
$end: set_marker_declaration $

  public Lexer(Reader reader) {

    this.br = new BufferedReader(reader);
  }

  public Token next()
      throws LexerException, IOException {
    Token token;
    do {
      token = internalNext();
    } while (token == null);
    return token;
  }

  Token internalNext()
      throws LexerException, IOException {

    boolean first = true;

    StringBuilder sb = new StringBuilder();
    State state = S_0.instance;

    while(state.getStateType() == State.StateType.TRANSITION) {
      TransitionState transitionState = (TransitionState) state;

      this.current_sb_length = sb.length();
      transitionState.setMarker(this);

      Symbol symbol;
      if(buffer.length() > 0) {
        char c = buffer.charAt(0);
        buffer.deleteCharAt(0);

        sb.append(c);
        symbol = Symbol.getSymbol(c);
      }
      else if(this.eof) {
        if(sb.length() == 0) {
          return new End(this.line, this.pos);
        }
        this.sb_contains_eof = true;
        symbol = Symbol.Symbol_end;
      }
      else {
        int i = br.read();
        if(i == -1) {
          this.eof = true;
          br.close();

          if(sb.length() == 0) {
            return new End(this.line, this.pos);
          }
          this.sb_contains_eof = true;
          symbol = Symbol.Symbol_end;
        }
        else {
          char c = (char) i;

          sb.append(c);
          symbol = Symbol.getSymbol(c);
        }
      }

      if(symbol == null) {
        throw new LexerException(sb.charAt(0), this.line, this.pos);
      }

      state = transitionState.getTarget(symbol);

      if(state == null) {
        throw new LexerException(sb.charAt(0), this.line, this.pos);
      }
    }

    FinalState finalState = (FinalState) state;

    this.sb = sb;

    return finalState.getToken(this);
  }

  int getAcceptLine() {
    return this.acceptLine;
  }

  int getAcceptPos() {
    return this.acceptPos;
  }

  private void updateLinePos(String text) {
    if(this.last_is_cr) {
      if(text.length() > 0) {
        if(text.charAt(0) != 10) {
          this.last_is_cr = false;
          this.line++;
          this.pos = 1;
        }
      }
      else if(this.buffer.length() > 0) {
        if(this.buffer.charAt(0) != 10) {
          this.last_is_cr = false;
          this.line++;
          this.pos = 1;
        }
      }
    }

    this.acceptLine = line;
    this.acceptPos = pos;

    for(int i = 0; i < text.length(); i++) {
      char c = text.charAt(i);

      if(c == 10) {
        this.line++;
        this.pos = 1;
      }
      else {
        if(last_is_cr) {
          this.line++;
          this.pos = 2;
        }
        else {
          this.pos++;
        }
      }

      this.last_is_cr = c == 13;
    }
  }

  String accept(int backCount) {
    if(this.sb_contains_eof) {
      this.sb_contains_eof = false;
      backCount--;
    }
    String text = this.sb.toString().substring(0, this.sb.length() - backCount);
    String leftover = this.sb.toString().substring(this.sb.length() - backCount, this.sb.length());
    this.buffer.insert(0, leftover);
    updateLinePos(text);
    return text;
  }

$macro: accept_marker_declaration(name) $
  String acceptWithMarker$name(int backCount) {
    if(this.sb_contains_eof) {
      this.sb_contains_eof = false;
    }
    String text = this.sb.toString().substring(0, this.marker$name - backCount);
    String leftover = this.sb.toString().substring(this.marker$name - backCount, this.sb.length());
    this.buffer.insert(0, leftover);
    updateLinePos(text);
    return text;
  }
$end: accept_marker_declaration $

}
$end: lexer $

$comment: ========== state ========== $

$macro: state $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class State {

  enum StateType {
    TRANSITION,
    FINAL;
  }

  abstract StateType getStateType();
}
$end: state $

$comment: ========== transition_state ========== $

$macro: transition_state $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class TransitionState
    extends State {

  abstract void setMarker(Lexer lexer);
  abstract State getTarget(Symbol symbol);

  StateType getStateType() {
    return State.StateType.TRANSITION;
  }
}
$end: transition_state $

$comment: ========== final_state ========== $

$macro: final_state $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class FinalState
    extends State {

  abstract Token getToken(Lexer lexer);

  StateType getStateType() {
    return State.StateType.FINAL;
  }
}
$end: final_state $

$comment: ========== transition_state_singleton ========== $

$macro: transition_state_singleton(number) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class S_$number
    extends TransitionState {

  static final S_$number instance = new S_$number();

  private S_$number() {
  }

$macro: set_marker(name) $
  void setMarker(Lexer lexer) {
    lexer.setMarker$name();
  }
$end: set_marker $
$macro: no_marker $
  void setMarker(Lexer lexer) {
  }
$end: no_marker $

  State getTarget(Symbol symbol) {
    switch(symbol) {
$macro: transition_target(symbol, target) $
    case Symbol_$(symbol):
      return S_$target.instance;
$end: transition_target $
    default:
      return null;
    }
  }

}
$end: transition_state_singleton $

$comment: ========== final_state_singleton ========== $

$macro: final_state_singleton(number,back_count) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class S_$number
    extends FinalState {

  static final S_$number instance = new S_$number();

  private S_$number() {
  }

  Token getToken(Lexer lexer) {
$macro: accept_token_no_marker $
    String text = lexer.accept($back_count);
$end: accept_token_no_marker $
$macro: accept_token_with_marker(marker_name) $
    String text = lexer.acceptWithMarker$marker_name($back_count);
$end: accept_token_with_marker $
    int line = lexer.getAcceptLine();
    int pos = lexer.getAcceptPos();

$macro: accept_normal_token(token_name) $
    return new N$token_name(text, line, pos);
$end: accept_normal_token $
$macro: accept_ignored_token $
    return null;
$end: accept_ignored_token $
  }
}
$end: final_state_singleton $

$comment: ========== symbol ========== $

$macro: symbol $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

enum Symbol {
$macro: symbol_declaration(name) $
  Symbol_$name,
$end: symbol_declaration $
  Symbol_end;

  static Symbol getSymbol(char c) {
    switch(c) {
$macro: single_char(bound, name) $
    case $(bound): return Symbol_$name;
$end: single_char $
    default:
$macro: open_interval(name) $
      return Symbol_$name;
$end: open_interval $
$macro: open_left_interval(upper_bound, name) $
      if(c <= $upper_bound) {
        return Symbol_$name;
      }
$end: open_left_interval $
$macro: open_right_interval(lower_bound, name) $
      if(c >= $lower_bound) {
        return Symbol_$name;
      }
$end: open_right_interval $
$macro: interval(lower_bound, upper_bound, name) $
      if(c >= $lower_bound && c <= $upper_bound) {
        return Symbol_$name;
      }
$end: interval $
    }

    return null;
  }
}
$end: symbol $

$comment: ========== lexer_exception ========== $

$macro: lexer_exception $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class LexerException
    extends Exception {

  private char c;
  private int line;
  private int pos;

  public LexerException(char c, int line, int pos) {
    this.c = c;
    this.line = line;
    this.pos = pos;
  }

  public char getChar() {
    return this.c;
  }

  public int getLine() {
    return this.line;
  }

  public int getPos() {
    return this.pos;
  }

  public String getMessage() {
    return "unrecognized char '" + getChar() + "' on line " + getLine() + ", pos " + getPos();
  }
}
$end: lexer_exception $

$comment: ========== end ========== $

$macro: end $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class End
    extends Token {

  public End(int line, int pos) {
    super("", line, pos);
  }

  @Override
  public Type getType() {
    return Type.TEnd;
  }

  @Override
  InternalType getInternalType() {
    return InternalType.TEnd;
  }
}
$end: end $
