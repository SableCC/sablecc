$comment$
This file is part of SableCC ( http://sablecc.org ).

See the NOTICE file distributed with this work for copyright information.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
$end$

$comment: ========== header ========== $

$text: header $
/* This file was generated by SableCC ( http://sablecc.org ). */
$end: header $

$comment: ========== default_package ========== $

$macro: default_package(language_name) $
package language_$language_name;
$end: default_package $

$comment: ========== specified_package ========== $

$macro: specified_package(language_name, package) $
package $package.language_$language_name;
$end: specified_package $

$comment: ========== node ========== $

$macro: node $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public abstract class Node {

  public abstract Type getType();

  public static enum Type {
$macro: node_type_enum_entry(name) $
    T_$name,
$end: node_type_enum_entry $
    TEnd,
    TAnonymous;
  }

  public abstract ProductionType getProductionType();

  public static enum ProductionType {
$macro: node_production_type_enum_entry(name) $
    T_$name,
$end: node_production_type_enum_entry $
    TNotAProduction;
  }

  public abstract String getText();
  public abstract int getLine();
  public abstract int getPos();
  public abstract void apply(Walker walker);
  public abstract void applyOnChildren(Walker walker);

  private Node parent;

  public Node getParent() {
    return this.parent;
  }

  void setParent(Node parent) {
    this.parent = parent;
  }

  @Override
  public String toString() {
    return "\\"" + getText() + "\\"@(" + getLine() + "," + getPos() + ")";
  }

  abstract InternalType getInternalType();

  static enum InternalType {
$macro: node_internal_type_enum_entry(name) $
    T_$name,
$end: node_internal_type_enum_entry $
    TEnd;
  }
}
$end: node $

$comment: ========== token ========== $

$macro: token $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public abstract class Token
    extends Node {

  private final String text;
  private final int line;
  private final int pos;

  public Token(String text, int line, int pos) {
    this.text = text;
    this.line = line;
    this.pos = pos;
  }

  @Override
  public ProductionType getProductionType() {
    return ProductionType.TNotAProduction;
  }

  @Override
  public String getText() {
    return this.text;
  }

  @Override
  public int getLine() {
    return this.line;
  }

  @Override
  public int getPos() {
    return this.pos;
  }

  @Override
  public void apply(Walker walker) {
    walker.defaultIn(this);
    walker.defaultCase(this);
    walker.defaultOut(this);
  }

  @Override
  public void applyOnChildren(Walker walker) {
  }
}
$end: token $

$comment: ========== custom_token ========== $

$macro: custom_token(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class N$name
    extends Token {

  public N$name(String text, int line, int pos) {
    super(text, line, pos);
  }

  @Override
  public Type getType() {
    return Type.T_$name;
  }

  @Override
  InternalType getInternalType() {
    return InternalType.T_$name;
  }

  @Override
  public void apply(Walker walker) {
    walker.in$name(this);
    walker.case$name(this);
    walker.out$name(this);
  }
}
$end: custom_token $

$comment: ========== anonymous_token ========== $

$macro: anonymous_token(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class N$name
    extends Token {

  N$name(String text, int line, int pos) {
    super(text, line, pos);
  }

  @Override
  public Type getType() {
    return Type.TAnonymous;
  }

  @Override
  InternalType getInternalType() {
    return InternalType.T_$name;
  }
}
$end: anonymous_token $

$comment: ========== lexer ========== $

$macro: lexer $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.io.*;

public class Lexer {

  private final BufferedReader br;
  private final StringBuilder buffer = new StringBuilder();
  private boolean eof;
  private int line = 1;
  private int pos = 1;
  private boolean last_is_cr;
  private StringBuilder sb;
  private int acceptLine;
  private int acceptPos;
  private int current_sb_length;
  private boolean sb_contains_eof;
$macro: marker_declaration(name) $
  private int marker$name;
$end: marker_declaration $

$macro: set_marker_declaration(name) $
  void setMarker$name() {
    this.marker$name = this.current_sb_length;
  }
$end: set_marker_declaration $

  public Lexer(Reader reader) {

    this.br = new BufferedReader(reader);
  }

  public Token next()
      throws LexerException, IOException {
    Token token;
    do {
      token = internalNext();
    } while (token == null);
    return token;
  }

  Token internalNext()
      throws LexerException, IOException {

    boolean first = true;

    StringBuilder sb = new StringBuilder();
    State state = S_0.instance;

    while(state.getStateType() == State.StateType.TRANSITION) {
      TransitionState transitionState = (TransitionState) state;

      this.current_sb_length = sb.length();
      transitionState.setMarker(this);

      Symbol symbol;
      if(buffer.length() > 0) {
        char c = buffer.charAt(0);
        buffer.deleteCharAt(0);

        sb.append(c);
        symbol = Symbol.getSymbol(c);
      }
      else if(this.eof) {
        if(sb.length() == 0) {
          return new End(this.line, this.pos);
        }
        this.sb_contains_eof = true;
        symbol = Symbol.Symbol_end;
      }
      else {
        int i = br.read();
        if(i == -1) {
          this.eof = true;
          br.close();

          if(sb.length() == 0) {
            return new End(this.line, this.pos);
          }
          this.sb_contains_eof = true;
          symbol = Symbol.Symbol_end;
        }
        else {
          char c = (char) i;

          sb.append(c);
          symbol = Symbol.getSymbol(c);
        }
      }

      if(symbol == null) {
        throw new LexerException(sb.charAt(0), this.line, this.pos);
      }

      state = transitionState.getTarget(symbol);

      if(state == null) {
        throw new LexerException(sb.charAt(0), this.line, this.pos);
      }
    }

    FinalState finalState = (FinalState) state;

    this.sb = sb;

    return finalState.getToken(this);
  }

  int getAcceptLine() {
    return this.acceptLine;
  }

  int getAcceptPos() {
    return this.acceptPos;
  }

  private void updateLinePos(String text) {
    if(this.last_is_cr) {
      if(text.length() > 0) {
        if(text.charAt(0) != 10) {
          this.last_is_cr = false;
          this.line++;
          this.pos = 1;
        }
      }
      else if(this.buffer.length() > 0) {
        if(this.buffer.charAt(0) != 10) {
          this.last_is_cr = false;
          this.line++;
          this.pos = 1;
        }
      }
    }

    this.acceptLine = line;
    this.acceptPos = pos;

    for(int i = 0; i < text.length(); i++) {
      char c = text.charAt(i);

      if(c == 10) {
        this.line++;
        this.pos = 1;
      }
      else {
        if(last_is_cr) {
          this.line++;
          this.pos = 2;
        }
        else {
          this.pos++;
        }
      }

      this.last_is_cr = c == 13;
    }
  }

  String accept(int backCount) {
    if(this.sb_contains_eof) {
      this.sb_contains_eof = false;
      backCount--;
    }
    String text = this.sb.toString().substring(0, this.sb.length() - backCount);
    String leftover = this.sb.toString().substring(this.sb.length() - backCount, this.sb.length());
    this.buffer.insert(0, leftover);
    updateLinePos(text);
    return text;
  }

$macro: accept_marker_declaration(name) $
  String acceptWithMarker$name(int backCount) {
    if(this.sb_contains_eof) {
      this.sb_contains_eof = false;
      backCount--;
    }
    String text = this.sb.toString().substring(0, this.marker$name - backCount);
    String leftover = this.sb.toString().substring(this.marker$name - backCount, this.sb.length());
    this.buffer.insert(0, leftover);
    updateLinePos(text);
    return text;
  }
$end: accept_marker_declaration $

}
$end: lexer $

$comment: ========== state ========== $

$macro: state $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class State {

  enum StateType {
    TRANSITION,
    FINAL;
  }

  abstract StateType getStateType();
}
$end: state $

$comment: ========== transition_state ========== $

$macro: transition_state $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class TransitionState
    extends State {

  abstract void setMarker(Lexer lexer);
  abstract State getTarget(Symbol symbol);

  StateType getStateType() {
    return State.StateType.TRANSITION;
  }
}
$end: transition_state $

$comment: ========== final_state ========== $

$macro: final_state $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class FinalState
    extends State {

  abstract Token getToken(Lexer lexer);

  StateType getStateType() {
    return State.StateType.FINAL;
  }
}
$end: final_state $

$comment: ========== transition_state_singleton ========== $

$macro: transition_state_singleton(number) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class S_$number
    extends TransitionState {

  static final S_$number instance = new S_$number();

  private S_$number() {
  }

$macro: set_marker(name) $
  void setMarker(Lexer lexer) {
    lexer.setMarker$name();
  }
$end: set_marker $
$macro: no_marker $
  void setMarker(Lexer lexer) {
  }
$end: no_marker $

  State getTarget(Symbol symbol) {
    switch(symbol) {
$macro: transition_target(symbol, target) $
    case Symbol_$(symbol):
      return S_$target.instance;
$end: transition_target $
    default:
      return null;
    }
  }

}
$end: transition_state_singleton $

$comment: ========== final_state_singleton ========== $

$macro: final_state_singleton(number,back_count) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class S_$number
    extends FinalState {

  static final S_$number instance = new S_$number();

  private S_$number() {
  }

  Token getToken(Lexer lexer) {
$macro: accept_token_no_marker $
    String text = lexer.accept($back_count);
$end: accept_token_no_marker $
$macro: accept_token_with_marker(marker_name) $
    String text = lexer.acceptWithMarker$marker_name($back_count);
$end: accept_token_with_marker $
    int line = lexer.getAcceptLine();
    int pos = lexer.getAcceptPos();

$macro: accept_normal_token(token_name) $
    return new N$token_name(text, line, pos);
$end: accept_normal_token $
$macro: accept_ignored_token $
    return null;
$end: accept_ignored_token $
  }
}
$end: final_state_singleton $

$comment: ========== symbol ========== $

$macro: symbol $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

enum Symbol {
$macro: symbol_declaration(name) $
  Symbol_$name,
$end: symbol_declaration $
  Symbol_end;

  static Symbol getSymbol(char c) {
    switch(c) {
$macro: single_char(bound, name) $
    case $(bound): return Symbol_$name;
$end: single_char $
    default:
$macro: open_interval(name) $
      return Symbol_$name;
$end: open_interval $
$macro: open_left_interval(upper_bound, name) $
      if(c <= $upper_bound) {
        return Symbol_$name;
      }
$end: open_left_interval $
$macro: open_right_interval(lower_bound, name) $
      if(c >= $lower_bound) {
        return Symbol_$name;
      }
$end: open_right_interval $
$macro: interval(lower_bound, upper_bound, name) $
      if(c >= $lower_bound && c <= $upper_bound) {
        return Symbol_$name;
      }
$end: interval $
    }

    return null;
  }
}
$end: symbol $

$comment: ========== lexer_exception ========== $

$macro: lexer_exception $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class LexerException
    extends Exception {

  private char c;
  private int line;
  private int pos;

  public LexerException(char c, int line, int pos) {
    this.c = c;
    this.line = line;
    this.pos = pos;
  }

  public char getChar() {
    return this.c;
  }

  public int getLine() {
    return this.line;
  }

  public int getPos() {
    return this.pos;
  }

  public String getMessage() {
    return "unrecognized char '" + getChar() + "' on line " + getLine() + ", pos " + getPos();
  }
}
$end: lexer_exception $

$comment: ========== parser_exception ========== $

$macro: parser_exception $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class ParserException
    extends Exception {

  private Token token;

  public ParserException(Token token) {
    this.token = token;
  }

  public Token getToken() {
    return this.token;
  }

  public String getMessage() {
    return "unexpected token '" + this.token.getText() + "' on line " + this.token.getLine() + ", pos " + this.token.getPos();
  }
}
$end: parser_exception $

$comment: ========== test ========== $

$macro: test $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.io.*;
public class Test {

  public static void main(String[] args)
    throws Exception {

    Reader in;

    if(args.length > 0) {
      in = new FileReader(args[0]);
    }
    else {
      in = new InputStreamReader(System.in);
    }

    Node syntaxTree = new Parser(in).parse();
    System.out.println();
    syntaxTree.apply(new Walker() {
      @Override
      public void defaultOut(Node node) {
        if(node instanceof Token) {
          System.out.println(node.getType() + ":\\"" + node.getText() + "\\"@(" + node.getLine() + "," + node.getPos() + ")");
        }
      }
    });
  }
}
$end: test $

$comment: ========== end ========== $

$macro: end $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class End
    extends Token {

  public End(int line, int pos) {
    super("", line, pos);
  }

  @Override
  public Type getType() {
    return Type.TEnd;
  }

  @Override
  InternalType getInternalType() {
    return InternalType.TEnd;
  }
}
$end: end $

$comment: ========== production ========== $

$macro: production(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

$macro: named_production_header $
public abstract class N$name
$end: named_production_header $
$macro: anonymous_production_header $
abstract class N$name
$end: anonymous_production_header $
    extends Node {

}
$end: production $

$comment: ========== public ========== $

$macro: public $
public $no_eol$
$end: public $

$comment: ========== alternative ========== $

$macro: alternative(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

$expand: public $
class N$name
    extends $expand: alternative_named_parent, alternative_node_parent $ {
$macro: alternative_named_parent(parent) $
N$(parent)$no_eol$
$end: alternative_named_parent $
$macro: alternative_node_parent $
Node$no_eol$
$end: alternative_node_parent $

  private final int line;
  private final int pos;
$expand: normal_element_declaration, end_element_declaration $

  @Override
  public int getLine() {
    return this.line;
  }

  @Override
  public int getPos() {
    return this.pos;
  }

  @Override
  public String getText() {
    return null;
  }

  @Override
  public void apply(Walker walker) {
$macro: alt_normal_apply $
    walker.in$name(this);
    walker.case$name(this);
    walker.out$name(this);
$end: alt_normal_apply $
$macro: alt_anonymous_apply $
    walker.defaultIn(this);
    walker.defaultCase(this);
    walker.defaultOut(this);
$end: alt_anonymous_apply $
  }

  @Override
  public void applyOnChildren(Walker walker) {
$expand: normal_child_apply, end_child_apply $
$macro: normal_child_apply(element_name) $
    this.e$element_name.apply(walker);
$end: normal_child_apply $
$macro: end_child_apply $
    this.e\$end.apply(walker);
$end: end_child_apply $
  }

  $expand: public_constructor $
$macro: public_constructor $
public $no_eol$
$end: public_constructor $
N$name(int line, int pos$expand: normal_constructor_parameter, end_constructor_parameter, before_first=", ", separator=", " $) {
$macro: normal_constructor_parameter(element_type, element_name) $
N$element_type p$(element_name)$no_eol$
$end: normal_constructor_parameter $
$macro: end_constructor_parameter $
End p\$end$no_eol$
$end: end_constructor_parameter $
    this.line = line;
    this.pos = pos;
$macro: normal_contructor_initialization(element_name) $
    this.e$element_name = p$element_name;
$end: normal_contructor_initialization $
$macro: end_contructor_initialization $
    this.e\$end = p\$end;
$end: end_contructor_initialization $
  }

  @Override
  public Type getType() {
$macro: named_alt_type $
    return Type.T_$name;
$end: named_alt_type $
$macro: anonymous_alt_type $
    return Type.TAnonymous;
$end: anonymous_alt_type $
  }

  @Override
  public ProductionType getProductionType() {
$macro: alt_prod_type(prod_name) $
    return ProductionType.T_$prod_name;
$end: alt_prod_type $
  }

  @Override
  InternalType getInternalType() {
    return InternalType.T_$name;
  }
$expand: public_element_accessor, before_first="\n", separator="\n" $
$expand: normal_element_accessor, end_element_accessor, before_first="\n", separator="\n" $
$macro: normal_element_declaration(element_type, element_name) $
  private final N$element_type e$element_name;
$end: normal_element_declaration $
$macro: public_element_accessor(element_name) $
  public $expand: public_element_type, token_element_type $ get_$element_name() {
$macro: public_element_type(element_type) $
N$(element_type)$no_eol$
$end: public_element_type $
$macro: token_element_type $
Token$no_eol$
$end: token_element_type $
    return this.e$element_name;
  }
$end: public_element_accessor$
$macro: normal_element_accessor(element_type, element_name) $
  N$element_type internalGet$element_name() {
    return this.e$element_name;
  }
$end: normal_element_accessor$
$macro: end_element_declaration $
  private final End e\$end;
$end: end_element_declaration $
$macro: end_element_accessor $
  End internalGet\$end() {
    return this.e\$end;
  }
$end: end_element_accessor$
}
$end: alternative $

$comment: ========== walker ========== $

$macro: walker $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class Walker {

$macro: walker_in(type_name) $
  public void in$type_name(N$type_name node) {
    defaultIn(node);
  }

$end: walker_in $
  public void defaultIn(Node node) {
  }

$macro: walker_case(type_name) $
  public void case$type_name(N$type_name node) {
    defaultCase(node);
  }

$end: walker_case $
  public void defaultCase(Node node) {
    node.applyOnChildren(this);
  }

$macro: walker_out(type_name) $
  public void out$type_name(N$type_name node) {
    defaultOut(node);
  }

$end: walker_out $
  public void defaultOut(Node node) {
  }
}
$end: walker $

$comment: ========== parser ========== $

$macro: parser $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.io.*;
import java.util.*;

public class Parser {

  private final Lexer lexer;
  private final ParseStack stack = new ParseStack();

  public Parser(Reader reader) {
    this.lexer = new Lexer(reader);
  }

  public Node parse()
      throws ParserException, LexerException, IOException {

    Node tree = null;
    while(tree == null) {
      tree = stack.getState().apply(this);
    }

    return tree;
  }

  ParseStack getStack() {
    return this.stack;
  }

  private LinkedList<Token> lookList = new LinkedList<Token>();

  Token look(int distance)
      throws LexerException, IOException {
    while(lookList.size() < distance) {
      lookList.addLast(lexer.next());
    }
    return lookList.get(distance - 1);
  }

  void shift()
      throws ParserException, LexerException, IOException {
    Token token;
    if(lookList.size() > 0) {
      token = lookList.removeFirst();
    }
    else {
      token = lexer.next();
    }
    stack.push(token, stack.getState().getTarget(token));
  }
}

class ParseStack {
  private ParseStackEntry stack = new ParseStackEntry(null, null, L_0.instance);
  private ParseStackEntry freeList;

  void push(Node node, LRState state) {
    ParseStackEntry entry;
    if(freeList != null) {
      entry = freeList;
      freeList = freeList.previous;
      entry.set(stack, node, state);
    }
    else {
      entry = new ParseStackEntry(stack, node, state);
    }
    stack = entry;
  }

  LRState getState() {
    return stack.state;
  }

  Node pop() {
    Node node = stack.node;
    ParseStackEntry entry = stack;
    stack = stack.previous;
    entry.set(freeList, null, null);
    freeList = entry;
    return node;
  }

  private static class ParseStackEntry {
    ParseStackEntry previous;
    Node node;
    LRState state;

    ParseStackEntry(
        ParseStackEntry previous,
        Node node,
        LRState state) {
     this.previous = previous;
     this.node = node;
     this.state = state;
    }

    void set(
        ParseStackEntry previous,
        Node node,
        LRState state) {
     this.previous = previous;
     this.node = node;
     this.state = state;
   }
  }
}

abstract class LRState {

  abstract Node apply(Parser parser)
      throws ParserException, LexerException, IOException;
  abstract LRState getTarget(Node node)
      throws ParserException, LexerException, IOException;
}
$macro: lr_state_singleton(number) $

class L_$number
    extends LRState {

  static final L_$number instance = new L_$number();

  private L_$number() {
  }

  @Override
  Node apply(Parser parser)
      throws ParserException, LexerException, IOException {

$macro: distance(distance) $
    // LR($distance) decisions
$macro: action $
    $expand: normal_group, false_group, before_first="if (", separator=" && ", after_last=") " ${
$macro: normal_group$
$expand: normal_condition, end_condition, before_many="(", separator=" || ", after_many=")" $
$end: normal_group $
$macro: normal_condition(ahead,token_type) $
parser.look($ahead).getInternalType() == Node.InternalType.T_$(token_type)$no_eol$
$end: normal_condition $
$macro: end_condition(ahead) $
parser.look($ahead).getInternalType() == Node.InternalType.TEnd$no_eol$
$end: end_condition $
$macro: false_group $
false$no_eol$
$end: false_group $
$macro: shift $
      parser.shift();
      return null;
$end: shift $
$macro: reduce(alternative) $
      ParseStack stack = parser.getStack();

$expand: reduce_normal_pop, reduce_end_pop $
$macro: reduce_normal_pop(element_type, element_name) $
      N$element_type l$element_name = (N$element_type) stack.pop();
$end: reduce_normal_pop $
$macro: reduce_end_pop $
      End l\$end = (End) stack.pop();
$end: reduce_end_pop $

$macro: normal_parameter(element_name) $
l$(element_name)$no_eol$
$end: normal_parameter $
$macro: end_parameter $
l\$end$no_eol$
$end: end_parameter $
$macro: reduce_decision $
      N$alternative l$alternative = new N$alternative(-1, -1$expand: normal_parameter, end_parameter, before_first=", ", separator=", " $);
      stack.push(l$alternative, stack.getState().getTarget(l$alternative));
      return null;
$end: reduce_decision $
$macro: accept_decision(element_name) $
      return l$element_name;
$end: accept_decision $
$end: reduce $
    }
$end: action $
$end: distance $
$macro: lr1_or_more $
    parser.shift();
    return null;
$end: lr1_or_more $
  }

  @Override
  LRState getTarget(Node node)
      throws ParserException, LexerException, IOException {

    switch(node.getProductionType()) {
$macro: production_lr_transition_target(node_type, target) $
    case T_$(node_type):
      return L_$target.instance;
$end: production_lr_transition_target $
    default:
      switch(node.getInternalType()) {
$macro: normal_token_lr_transition_target(node_type, target) $
        case T_$(node_type):
          return L_$target.instance;
$end: normal_token_lr_transition_target $
$macro: end_token_lr_transition_target(target) $
        case TEnd:
          return L_$target.instance;
$end: end_token_lr_transition_target $
        default:
          throw new ParserException((Token) node);
      }
    }
  }
}
$end: lr_state_singleton $
$end: parser $
