$comment$
This file is part of SableCC ( http://sablecc.org ).

See the NOTICE file distributed with this work for copyright information.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
$end$

$comment: ========== header ========== $

$text: header $
/* This file was generated by SableCC ( http://sablecc.org ). */
$end: header $

$comment: ========== default_package ========== $

$macro: default_package(language_name) $
package language_$language_name;
$end: default_package $

$comment: ========== specified_package ========== $

$macro: specified_package(language_name, package) $
package $package.language_$language_name;
$end: specified_package $

$comment: ========== node ========== $

$macro: node $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public abstract class Node {

  public static enum Type {
$macro: node_type_enum_entry(name) $
    T_$name,
$end: node_type_enum_entry $
    TEnd,
    TAnonymous;
  }

  public abstract Type getType();
  public abstract String getText();
  public abstract int getLine();
  public abstract int getPos();
  public abstract void apply(Walker walker);
  public abstract void applyOnChildren(Walker walker);

  @Override
  public String toString() {
    return "\\"" + getText() + "\\"@(" + getLine() + "," + getPos() + ")";
  }

  abstract InternalType getInternalType();

  static enum InternalType {
$macro: node_internal_type_enum_entry(name) $
    T_$name,
$end: node_internal_type_enum_entry $
    TEnd;
  }
}
$end: node $

$comment: ========== token ========== $

$macro: token $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public abstract class Token
    extends Node {

  private final String text;
  private final int line;
  private final int pos;

  public Token(String text, int line, int pos) {
    this.text = text;
    this.line = line;
    this.pos = pos;
  }

  @Override
  public String getText() {
    return this.text;
  }

  @Override
  public int getLine() {
    return this.line;
  }

  @Override
  public int getPos() {
    return this.pos;
  }

  @Override
  public void apply(Walker walker) {
    walker.defaultIn(this);
    walker.defaultCase(this);
    walker.defaultOut(this);
  }

  @Override
  public void applyOnChildren(Walker walker) {
  }
}
$end: token $

$comment: ========== custom_token ========== $

$macro: custom_token(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class N$name
    extends Token {

  public N$name(String text, int line, int pos) {
    super(text, line, pos);
  }

  @Override
  public Type getType() {
    return Node.Type.T_$name;
  }

  @Override
  InternalType getInternalType() {
    return Node.InternalType.T_$name;
  }

  @Override
  public void apply(Walker walker) {
    walker.in$name(this);
    walker.case$name(this);
    walker.out$name(this);
  }
}
$end: custom_token $

$comment: ========== anonymous_token ========== $

$macro: anonymous_token(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class N$name
    extends Token {

  N$name(String text, int line, int pos) {
    super(text, line, pos);
  }

  @Override
  public Type getType() {
    return Node.Type.TAnonymous;
  }

  @Override
  InternalType getInternalType() {
    return Node.InternalType.T_$name;
  }
}
$end: anonymous_token $

$comment: ========== lexer ========== $

$macro: lexer $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.io.*;

public class Lexer {

  private final BufferedReader br;
  private final StringBuilder buffer = new StringBuilder();
  private boolean eof;
  private int line = 1;
  private int pos = 1;
  private boolean last_is_cr;
  private StringBuilder sb;
  private int acceptLine;
  private int acceptPos;
  private int current_sb_length;
  private boolean sb_contains_eof;
$macro: marker_declaration(name) $
  private int marker$name;
$end: marker_declaration $

$macro: set_marker_declaration(name) $
  void setMarker$name() {
    this.marker$name = this.current_sb_length;
  }
$end: set_marker_declaration $

  public Lexer(Reader reader) {

    this.br = new BufferedReader(reader);
  }

  public Token next()
      throws LexerException, IOException {
    Token token;
    do {
      token = internalNext();
    } while (token == null);
    return token;
  }

  Token internalNext()
      throws LexerException, IOException {

    boolean first = true;

    StringBuilder sb = new StringBuilder();
    State state = S_0.instance;

    while(state.getStateType() == State.StateType.TRANSITION) {
      TransitionState transitionState = (TransitionState) state;

      this.current_sb_length = sb.length();
      transitionState.setMarker(this);

      Symbol symbol;
      if(buffer.length() > 0) {
        char c = buffer.charAt(0);
        buffer.deleteCharAt(0);

        sb.append(c);
        symbol = Symbol.getSymbol(c);
      }
      else if(this.eof) {
        if(sb.length() == 0) {
          return new End(this.line, this.pos);
        }
        this.sb_contains_eof = true;
        symbol = Symbol.Symbol_end;
      }
      else {
        int i = br.read();
        if(i == -1) {
          this.eof = true;
          br.close();

          if(sb.length() == 0) {
            return new End(this.line, this.pos);
          }
          this.sb_contains_eof = true;
          symbol = Symbol.Symbol_end;
        }
        else {
          char c = (char) i;

          sb.append(c);
          symbol = Symbol.getSymbol(c);
        }
      }

      if(symbol == null) {
        throw new LexerException(sb.charAt(0), this.line, this.pos);
      }

      state = transitionState.getTarget(symbol);

      if(state == null) {
        throw new LexerException(sb.charAt(0), this.line, this.pos);
      }
    }

    FinalState finalState = (FinalState) state;

    this.sb = sb;

    return finalState.getToken(this);
  }

  int getAcceptLine() {
    return this.acceptLine;
  }

  int getAcceptPos() {
    return this.acceptPos;
  }

  private void updateLinePos(String text) {
    if(this.last_is_cr) {
      if(text.length() > 0) {
        if(text.charAt(0) != 10) {
          this.last_is_cr = false;
          this.line++;
          this.pos = 1;
        }
      }
      else if(this.buffer.length() > 0) {
        if(this.buffer.charAt(0) != 10) {
          this.last_is_cr = false;
          this.line++;
          this.pos = 1;
        }
      }
    }

    this.acceptLine = line;
    this.acceptPos = pos;

    for(int i = 0; i < text.length(); i++) {
      char c = text.charAt(i);

      if(c == 10) {
        this.line++;
        this.pos = 1;
      }
      else {
        if(last_is_cr) {
          this.line++;
          this.pos = 2;
        }
        else {
          this.pos++;
        }
      }

      this.last_is_cr = c == 13;
    }
  }

  String accept(int backCount) {
    if(this.sb_contains_eof) {
      this.sb_contains_eof = false;
      backCount--;
    }
    String text = this.sb.toString().substring(0, this.sb.length() - backCount);
    String leftover = this.sb.toString().substring(this.sb.length() - backCount, this.sb.length());
    this.buffer.insert(0, leftover);
    updateLinePos(text);
    return text;
  }

$macro: accept_marker_declaration(name) $
  String acceptWithMarker$name(int backCount) {
    if(this.sb_contains_eof) {
      this.sb_contains_eof = false;
      backCount--;
    }
    String text = this.sb.toString().substring(0, this.marker$name - backCount);
    String leftover = this.sb.toString().substring(this.marker$name - backCount, this.sb.length());
    this.buffer.insert(0, leftover);
    updateLinePos(text);
    return text;
  }
$end: accept_marker_declaration $

}
$end: lexer $

$comment: ========== state ========== $

$macro: state $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class State {

  enum StateType {
    TRANSITION,
    FINAL;
  }

  abstract StateType getStateType();
}
$end: state $

$comment: ========== transition_state ========== $

$macro: transition_state $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class TransitionState
    extends State {

  abstract void setMarker(Lexer lexer);
  abstract State getTarget(Symbol symbol);

  StateType getStateType() {
    return State.StateType.TRANSITION;
  }
}
$end: transition_state $

$comment: ========== final_state ========== $

$macro: final_state $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class FinalState
    extends State {

  abstract Token getToken(Lexer lexer);

  StateType getStateType() {
    return State.StateType.FINAL;
  }
}
$end: final_state $

$comment: ========== transition_state_singleton ========== $

$macro: transition_state_singleton(number) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class S_$number
    extends TransitionState {

  static final S_$number instance = new S_$number();

  private S_$number() {
  }

$macro: set_marker(name) $
  void setMarker(Lexer lexer) {
    lexer.setMarker$name();
  }
$end: set_marker $
$macro: no_marker $
  void setMarker(Lexer lexer) {
  }
$end: no_marker $

  State getTarget(Symbol symbol) {
    switch(symbol) {
$macro: transition_target(symbol, target) $
    case Symbol_$(symbol):
      return S_$target.instance;
$end: transition_target $
    default:
      return null;
    }
  }

}
$end: transition_state_singleton $

$comment: ========== final_state_singleton ========== $

$macro: final_state_singleton(number,back_count) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class S_$number
    extends FinalState {

  static final S_$number instance = new S_$number();

  private S_$number() {
  }

  Token getToken(Lexer lexer) {
$macro: accept_token_no_marker $
    String text = lexer.accept($back_count);
$end: accept_token_no_marker $
$macro: accept_token_with_marker(marker_name) $
    String text = lexer.acceptWithMarker$marker_name($back_count);
$end: accept_token_with_marker $
    int line = lexer.getAcceptLine();
    int pos = lexer.getAcceptPos();

$macro: accept_normal_token(token_name) $
    return new N$token_name(text, line, pos);
$end: accept_normal_token $
$macro: accept_ignored_token $
    return null;
$end: accept_ignored_token $
  }
}
$end: final_state_singleton $

$comment: ========== symbol ========== $

$macro: symbol $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

enum Symbol {
$macro: symbol_declaration(name) $
  Symbol_$name,
$end: symbol_declaration $
  Symbol_end;

  static Symbol getSymbol(char c) {
    switch(c) {
$macro: single_char(bound, name) $
    case $(bound): return Symbol_$name;
$end: single_char $
    default:
$macro: open_interval(name) $
      return Symbol_$name;
$end: open_interval $
$macro: open_left_interval(upper_bound, name) $
      if(c <= $upper_bound) {
        return Symbol_$name;
      }
$end: open_left_interval $
$macro: open_right_interval(lower_bound, name) $
      if(c >= $lower_bound) {
        return Symbol_$name;
      }
$end: open_right_interval $
$macro: interval(lower_bound, upper_bound, name) $
      if(c >= $lower_bound && c <= $upper_bound) {
        return Symbol_$name;
      }
$end: interval $
    }

    return null;
  }
}
$end: symbol $

$comment: ========== lexer_exception ========== $

$macro: lexer_exception $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class LexerException
    extends Exception {

  private char c;
  private int line;
  private int pos;

  public LexerException(char c, int line, int pos) {
    this.c = c;
    this.line = line;
    this.pos = pos;
  }

  public char getChar() {
    return this.c;
  }

  public int getLine() {
    return this.line;
  }

  public int getPos() {
    return this.pos;
  }

  public String getMessage() {
    return "unrecognized char '" + getChar() + "' on line " + getLine() + ", pos " + getPos();
  }
}
$end: lexer_exception $

$comment: ========== test ========== $

$macro: test $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.io.*;
public class Test {

  public static void main(String[] args)
    throws Exception {

    Reader in;

    if(args.length > 0) {
      in = new FileReader(args[0]);
    }
    else {
      in = new InputStreamReader(System.in);
    }

    Lexer lexer = new Lexer(in);
    Token token;
    do {
      token = lexer.next();
      System.out.println(token);
    } while (token.getType() != Node.Type.TEnd);
  }
}
$end: test $

$comment: ========== end ========== $

$macro: end $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class End
    extends Token {

  public End(int line, int pos) {
    super("", line, pos);
  }

  @Override
  public Type getType() {
    return Node.Type.TEnd;
  }

  @Override
  InternalType getInternalType() {
    return Node.InternalType.TEnd;
  }
}
$end: end $

$comment: ========== production ========== $

$macro: production(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

$macro: named_production_header $
public abstract class N$name
$end: named_production_header $
$macro: anonymous_production_header $
abstract class N$name
$end: anonymous_production_header $
    extends Node {

}
$end: production $

$comment: ========== public ========== $

$macro: public $
public $no_eol$
$end: public $

$comment: ========== alternative ========== $

$macro: alternative(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

$expand: public $
class N$name
    extends $expand: alternative_named_parent, alternative_node_parent $ {
$macro: alternative_named_parent(parent) $
N$(parent)$no_eol$
$end: alternative_named_parent $
$macro: alternative_node_parent $
Node$no_eol$
$end: alternative_node_parent $

  private final int line;
  private final int pos;
$expand: normal_element_declaration, end_element_declaration $

  @Override
  public int getLine() {
    return this.line;
  }

  @Override
  public int getPos() {
    return this.pos;
  }

  @Override
  public String getText() {
    return null;
  }

  @Override
  public void apply(Walker walker) {
$macro: alt_normal_apply $
    walker.in$name(this);
    walker.case$name(this);
    walker.out$name(this);
$end: alt_normal_apply $
$macro: alt_anonymous_apply $
    walker.defaultIn(this);
    walker.defaultCase(this);
    walker.defaultOut(this);
$end: alt_anonymous_apply $
  }

  @Override
  public void applyOnChildren(Walker walker) {
$macro: normal_child_apply(element_name) $
    this.e$element_name.apply(walker);
$end: normal_child_apply $
$macro: end_child_apply $
    this.e\$end.apply(walker);
$end: end_child_apply $
  }

  $expand: public_constructor $
$macro: public_constructor $
public $no_eol$
$end: public_constructor $
N$name(int line, int pos$expand: normal_constructor_parameter, end_constructor_parameter, before_first=", ", separator=", " $) {
$macro: normal_constructor_parameter(element_type, element_name) $
N$element_type p$(element_name)$no_eol$
$end: normal_constructor_parameter $
$macro: end_constructor_parameter $
End p\$end$no_eol$
$end: end_constructor_parameter $
    this.line = line;
    this.pos = pos;
$macro: normal_contructor_initialization(element_name) $
    this.e$element_name = p$element_name;
$end: normal_contructor_initialization $
$macro: end_contructor_initialization $
    this.e\$end = p\$end;
$end: end_contructor_initialization $
  }

  @Override
  public Type getType() {
$macro: named_alt_type $
    return Node.Type.T_$name;
$end: named_alt_type $
$macro: anonymous_alt_type $
    return Node.Type.TAnonymous;
$end: anonymous_alt_type $
  }

  @Override
  InternalType getInternalType() {
    return Node.InternalType.T_$name;
  }
$expand: public_element_accessor, before_first="\n", separator="\n" $
$expand: normal_element_accessor, end_element_accessor, before_first="\n", separator="\n" $
$macro: normal_element_declaration(element_type, element_name) $
  private final N$element_type e$element_name;
$end: normal_element_declaration $
$macro: public_element_accessor(element_name) $
  public $expand: public_element_type, token_element_type $ get$element_name() {
$macro: public_element_type(element_type) $
N$(element_type)$no_eol$
$end: public_element_type $
$macro: token_element_type $
Token$no_eol$
$end: token_element_type $
    return this.e$element_name;
  }
$end: public_element_accessor$
$macro: normal_element_accessor(element_type, element_name) $
  N$element_type internalGet$element_name() {
    return this.e$element_name;
  }
$end: normal_element_accessor$
$macro: end_element_declaration $
  private final End e\$end;
$end: end_element_declaration $
$macro: end_element_accessor $
  End internalGet\$end() {
    return this.e\$end;
  }
$end: end_element_accessor$
}
$end: alternative $

$comment: ========== walker ========== $

$macro: walker $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class Walker {

$macro: walker_in(type_name) $
  public void in$type_name(N$type_name node) {
    defaultIn(node);
  }

$end: walker_in $
  public void defaultIn(Node node) {
  }

$macro: walker_case(type_name) $
  public void case$type_name(N$type_name node) {
    defaultCase(node);
  }

$end: walker_case $
  public void defaultCase(Node node) {
    node.applyOnChildren(this);
  }

$macro: walker_out(type_name) $
  public void out$type_name(N$type_name node) {
    defaultOut(node);
  }

$end: walker_out $
  public void defaultOut(Node node) {
  }
}
$end: walker $
