#This file is part of SableCC ( http://sablecc.org ).
#
#See the NOTICE file distributed with this work for copyright information.
#
#Licensed under the Apache License, Version 2.0 (the "License");
#you may not use this file except in compliance with the License.
#You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
#Unless required by applicable law or agreed to in writing, software
#distributed under the License is distributed on an "AS IS" BASIS,
#WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#See the License for the specific language governing permissions and
#limitations under the License.

#========== header ==========
Macro header
{Body}
/* This file was generated by SableCC's ObjectMacro. */
{End}

#========== package_declaration ==========
Macro package_declaration
  Param
    package_name : String;
{Body}
package {package_name};
{End}

#========== import_java_util ==========
Macro import_java_util
{Body}
import java.util.*;
{End}

#========== context ==============
Macro context
  Param
    package_declaration : package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

public class Context {

}
{End}

#========== internals_initializer =========
Macro internals_initializer
  Param
    package_declaration : package_declaration, before_first="\n";
    parent_internal_setter : parent_internals_setter, separator="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

public class InternalsInitializer {

    private final String _paramName;

    InternalsInitializer(String paramName){
        this._paramName = paramName;
    }

{parent_internal_setter}

}
{End}

#========== parent_internals_setter =========
Macro parent_internals_setter
  Param
    name : String;
{Body}
void set{name}(M{name} m{name}){
  throw ObjectMacroException.incorrectType("M{name}", this._paramName);
}
{End}

#============ cycle_detector =============
Macro cycle_detector_class
    Param
        package_declaration : package_declaration, before_first="\n";

{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

public class CycleDetector {

    private Macro receiver;

    private Set<Macro> visited;

    void detectCycle(
            Macro receiver,
            Macro added){

        this.visited = new LinkedHashSet<>();
        this.receiver = receiver;
        detectCycle(added);
    }

    private void detectCycle(
            Macro macro){

        if(this.visited.contains(macro)){
            return;
        }

        if(macro == this.receiver){
            throw ObjectMacroException.cyclicReference(macro.getClass().getSimpleName());
        }

        this.visited.add(macro);

        for(Macro child : macro.getChildren()){
            detectCycle(child);
        }
    }
}
{End}

#========== super_macro ==========
Macro super_macro
  Param
    package_declaration : package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

public abstract class Macro {

    final static String LINE_SEPARATOR = System.getProperty("line.separator");

    BuildState build_state = null;

    final Map<Context, BuildState> build_states = new LinkedHashMap<>();

    final LinkedList<Macro> children = new LinkedList<>();

    static final CycleDetector cycleDetector = new CycleDetector();

    public String build(){

        throw new RuntimeException("build cannot be invoked here");
    }

    String build(
            Context context){

        throw new RuntimeException("build cannot be invoked here");
    }

    void apply(
            InternalsInitializer internalsInitializer){

        throw new RuntimeException("apply cannot be called here");
    }

    LinkedList<Macro> getChildren(){
        return this.children;
    }
}
{End}

#=============== super_directive ==============

Macro super_directive
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

abstract class Directive {

    final String value;

    Directive(
            String value) {

        this.value = value;
    }

    abstract String apply(Integer index, String macro, Integer list_size);
}
{End}

#=============== class_internal_value =========
Macro class_internal_value
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

class InternalValue {

    private final List<Macro> macros;

    private DAfterLast dAfterLast;

    private DBeforeFirst dBeforeFirst;

    private DSeparator dSeparator;

    private DNone dNone;

    private final Context context;

    private String cache;

    InternalValue(
            List<Macro> macros,
            Context context){

        this.macros = macros;
        this.context = context;
    }

    String build(){

        if(this.cache != null){
            return this.cache;
        }

        StringBuilder sb = new StringBuilder();
        int i = 0;
        int nb_macros = this.macros.size();

        if(this.dNone != null){
            sb.append(this.dNone.apply(i, "", nb_macros));
        }

        for(Macro macro : this.macros){
            String expansion = macro.build(this.context);

            if(this.dBeforeFirst != null){
                expansion = dBeforeFirst.apply(i, expansion, nb_macros);
            }

            if(dAfterLast != null){
                expansion = dAfterLast.apply(i, expansion, nb_macros);
            }

            if(this.dSeparator != null){
                expansion = dSeparator.apply(i, expansion, nb_macros);
            }

            sb.append(expansion);
            i++;
        }

        this.cache = sb.toString();
        return this.cache;
    }

    void setNone(
                DNone none){

        this.dNone = none;
    }

    void setBeforeFirst(
            DBeforeFirst dBeforeFirst){

        this.dBeforeFirst = dBeforeFirst;
    }

    void setAfterLast(
            DAfterLast dAfterLast){

        this.dAfterLast = dAfterLast;
    }

    void setSeparator(
            DSeparator dSeparator){

        this.dSeparator = dSeparator;
    }
}
{End}

#=============== class_build_state =========
Macro class_build_state
    Param
        package_declaration: package_declaration,before_first="\n";
{Body}
{Insert: header}
{package_declaration}

class BuildState {

    private String expansion = null;

    public String getExpansion() {
        return expansion;
    }

    public void setExpansion(
            String expansion) {

        this.expansion = expansion;
    }
}
{End}

#========== macro ==========
Macro macro
  Param
    name : String;
    package_declaration : package_declaration, before_first="\n";
    fields : param_macro_field, param_string_field, internal_macro_field, internal_string_field, internal_macros_value_field, directive_fields, separator="\n\n", before_first="\n";
    context_fields : context_field, before_first="\n", separator="\n\n";
    constructor : constructor, before_first="\n";
    setters : param_string_setter, single_add, internal_string_setter, internal_macro_setter, separator="\n\n", before_first="\n";
    builders : param_string_ref_builder, param_macro_ref_builder, internal_macro_ref_builder, separator="\n\n", before_first="\n";
    getters : param_string_ref, param_macro_ref, internal_macro_ref, separator="\n\n", before_first="\n";
    init_internals_methods : init_internals_method, separator="\n\n";
    init_directives : init_directives, separator="\n\n", before_first="\n";
    redefined_apply_initializer : redefined_apply_initializer;
    macro_builder : macro_builder, before_first="\n";
    empty_builder_with_context : empty_builder_with_context, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

{Insert: import_java_util}

public class M{name} extends Macro{
{Indent: "\t"}
{fields}

{context_fields}

{constructor}

{setters}

{builders}

{getters}

{init_internals_methods}

{init_directives}

{redefined_apply_initializer}

{macro_builder}

{empty_builder_with_context}

{End}
    private String applyIndent(
                            String macro,
                            String indent){

            StringBuilder sb = new StringBuilder();
            String[] lines = macro.split( "\\n");

            if(lines.length > 1){
                for(int i = 0; i < lines.length; i++){
                    String line = lines[i];
                    sb.append(indent).append(line);

                    if(i < lines.length - 1){
                        sb.append(LINE_SEPARATOR);
                    }
                }
            }
            else{
                sb.append(indent).append(macro);
            }

            return sb.toString();
    }
}
{End}

#======================================================
#===================== CONSTRUCTOR ====================
#======================================================

#========== constructor ==========
Macro constructor
  Param
    name : String;
    field_initializers : set_param, init_macro_param, init_macro_internal, init_string_internal, before_first="\n", separator="\n";
    parameters : string_param, separator=", ";
    internal_values_initializers : init_internal_value, before_first="\n", separator="\n";
{Body}
public M{name}({parameters}){
{field_initializers}
{internal_values_initializers}
}
{End}

#========== init_macro_internal ===========
Macro init_macro_internal
  Param
    name : String;
{Body}
    this.list_{name} = new LinkedHashMap<>();
{End}

#========== init_macro_param ===========
Macro init_macro_param
    Param
        name: String;
{Body}
    this.list_{name} = new ArrayList<>();
{End}

#========== init_string_internal ===========
Macro init_string_internal
  Param
    name : String;
{Body}
    this.field_{name} = new LinkedHashMap<>();
{End}

#========== init_internal_value ============

Macro init_internal_value
    Param
        param_name: String;
{Body}
    this.{param_name}Value = new InternalValue(this.list_{param_name}, this.{param_name}Context);
{End}

#========== set_param ==========
Macro set_param
  Param
    name : String;
    set_param : param_arg;
{Body}
        this.setP{name}({set_param});
{End}

#================================================================
#===================== MACRO FUNCTIONS ==========================
#================================================================
#========= single_add ===========

Macro single_add
    Param
        macro_name: String;
        param_name: String;
        is_built: is_built(macro_name);
{Body}
public void add{param_name}(M{macro_name} macro){
    if(macro == null){
        throw ObjectMacroException.parameterNull("{param_name}");
    }
{Indent: "\t"}
{is_built}
{End}

    this.list_{param_name}.add(macro);
    this.children.add(macro);
    Macro.cycleDetector.detectCycle(this, macro);
}
{End}

#=========== is_built ===========
Macro is_built
    Internal
        macro_name: String;
{Body}
        if(this.build_state != null){
            throw ObjectMacroException.cannotModify("{macro_name}");
        }
{End}

#=========== param_string_ref_builder =============
Macro param_string_ref_builder
  Param
    name : String;
    context_param : context_param;
    get_internal_tail : get_internal_tail;
{Body}
private String build{name}({context_param}){

    return this.field_{name}{get_internal_tail};
}
{End}

#========== param_macro_ref_builder ==================
Macro param_macro_ref_builder
    Param
        name: String;
        context_name: context_name, none="context";
{Body}
private String build{name}(){
    StringBuilder sb = new StringBuilder();
    Context local_context = {context_name};
    List<Macro> macros = this.list_{name};

    int i = 0;
    int nb_macros = macros.size();
    String expansion = null;

    if(this.{name}None != null){
        sb.append(this.{name}None.apply(i, "", nb_macros));
    }

    for(Macro macro : macros){
        expansion = macro.build(local_context);

        if(this.{name}BeforeFirst != null){
            expansion = this.{name}BeforeFirst.apply(i, expansion, nb_macros);
        }

        if(this.{name}AfterLast != null){
            expansion = this.{name}AfterLast.apply(i, expansion, nb_macros);
        }

        if(this.{name}Separator != null){
            expansion = this.{name}Separator.apply(i, expansion, nb_macros);
        }

        sb.append(expansion);
        i++;
    }

    return sb.toString();
}
{End}

#=========== internal_macro_ref_builder ================

Macro internal_macro_ref_builder
    Param
        internal_name: String;
{Body}
private String build{internal_name}(Context context){

    InternalValue macros = this.list_{internal_name}.get(context);
    return macros.build();
}
{End}

#========= internal_macro_setter =========
Macro internal_macro_setter
  Param
    param_name : String;
{Body}
    void set{param_name}(
                Context context,
                InternalValue internal_value) {

            if(internal_value == null){
                throw new RuntimeException("macros cannot be null");
            }

            this.list_{param_name}.put(context, internal_value);
        }
{End}

#=========== param_string_setter =========
Macro param_string_setter
  Param
    name : String;
    string_param : string_param;
    param_arg : param_arg;
{Body}
private void setP{name}( {string_param} ){
    if({param_arg} == null){
        throw ObjectMacroException.parameterNull("{name}");
    }

    this.field_{name} = {param_arg};
}
{End}

#========== param_macro_ref ==============
Macro param_macro_ref
  Param
    name : String;
{Body}
private InternalValue get{name}(){
    return this.{name}Value;
}
{End}

#========== internal_macro_ref ===========

Macro internal_macro_ref
    Param
        param_name: String;
{Body}
private InternalValue get{param_name}(Context context){
    return this.list_{param_name}.get(context);
}
{End}

#========== param_string_ref ==============
Macro param_string_ref
  Param
    name : String;
    context_param : context_param;
    get_internal_tail : get_internal_tail;
{Body}
private String get{name}({context_param}){

    return this.field_{name}{get_internal_tail};
}
{End}

#========= internal_string_setter =========
Macro internal_string_setter
  Param
    name : String;
{Body}
    void set{name}(
            Context context,
            String value) {

        if(value == null){
            throw new RuntimeException("value cannot be null here");
        }

        this.field_{name}.put(context, value);
    }
{End}

#========= init_internals_method ========
Macro init_internals_method
    Param
        name: String;
        apply_internals_initializer: apply_internals_initializer, separator = "\n";
{Body}
private void init{name}Internals(Context context){
    for(Macro macro : this.list_{name}){
{Indent: "\t\t"}
{apply_internals_initializer}
{End}
    }
}
{End}

#=========== init_directives ===========

Macro init_directives
    Param
        param_name: String;
        new_directive: new_directive(param_name);
{Body}
private void init{param_name}Directives(){
{Indent: "\t"}
{new_directive}
{End}
}
{End}

#=========== new_directives ===========
Macro new_directive
    Param
        directive_name: String;
        index_builder: String;
        macro_body_parts: string_part, param_insert_part, eol_part, insert_macro_part;
    Internal
        param_name: String;
{Body}
StringBuilder sb{index_builder} = new StringBuilder();
{macro_body_parts}
this.{param_name}{directive_name} = new D{directive_name}(sb{index_builder}.toString());
this.{param_name}Value.set{directive_name}(this.{param_name}{directive_name});
{End}

#============================================
#============== MACRO BUILDER ===============
#============================================

#========= public =============
Macro public
{Body}
public
{End}

#========== macro_builder =======
Macro macro_builder
  Param
    macro_name: String;
    context_param : context_param;
    context_build_state : context_build_state, none="this.build_state";
    new_build_state : new_build_state, none="this.build_state = buildState";
    directives_calls : init_directive_call, separator="\n";
    internals_calls : init_internals_call, separator="\n";
    macro_body_parts : init_string_builder, string_part, param_insert_part,  eol_part, insert_macro_part, add_indent, indent_part, separator="\n";
{Body}
@Override
{Insert: public} String build({context_param}){

    BuildState buildState = {context_build_state};

    if(buildState == null){
        buildState = new BuildState();
    }
    else if(buildState.getExpansion() == null){
        throw ObjectMacroException.cyclicReference("{macro_name}");
    }
    else{
        return buildState.getExpansion();
    }
    {new_build_state};
    List<String> indentations = new LinkedList<>();
    StringBuilder sbIndentation = new StringBuilder();

{Indent: "\t"}
{directives_calls}

{internals_calls}
{End}

    StringBuilder sb0 = new StringBuilder();

{Indent: "\t"}
{macro_body_parts}
{End}

    buildState.setExpansion(sb0.toString());
    return sb0.toString();
}
{End}

Macro init_directive_call
    Param
        param_name: String;
{Body}
init{param_name}Directives();
{End}

Macro init_internals_call
    Param
        param_name: String;
        context_arg: context_arg, none="null";
{Body}
init{param_name}Internals({context_arg});
{End}

#============ empty_builder_with_context ============
Macro empty_builder_with_context
{Body}
@Override
String build(Context context) {
 return build();
}
{End}

#========== context_build_state =======
Macro context_build_state
{Body}
this.build_states.get(context)
{End}

#========== new_build_state =========
Macro new_build_state
{Body}
this.build_states.put(context, buildState)
{End}

#========= redefined_apply_initializer =======
Macro redefined_apply_initializer
  Param
    name : String;
{Body}
@Override
 void apply(
         InternalsInitializer internalsInitializer){

     internalsInitializer.set{name}(this);
 }
{End}

#===================================================
#================= MACRO FIELDS ====================
#===================================================

#========== param_macro_field ==========
Macro param_macro_field
  Param
    name : String;
{Body}
private final List<Macro> list_{name};
{End}

#========== param_string_field ==========
Macro param_string_field
  Param
    name : String;
{Body}
private String field_{name};
{End}

#========== internal_macro_field ==========
Macro internal_macro_field
  Param
    name : String;
{Body}
private Map<Context, InternalValue> list_{name} = new LinkedHashMap<>();
{End}

#========== internal_string_field ==========
Macro internal_string_field
  Param
    name : String;
{Body}
private Map<Context, String> field_{name} = new LinkedHashMap<>();
{End}

#========== context_field =========
Macro context_field
  Param
    name : String;
{Body}
private final Context {name}Context = new Context();
{End}

# =========== internal_macros_value_field ========
Macro internal_macros_value_field
    Param
        param_name: String;
{Body}
private final InternalValue {param_name}Value;
{End}

#========== directive_fields ==========
Macro directive_fields
    Param
        param_name: String;
{Body}
private DSeparator {param_name}Separator;

private DBeforeFirst {param_name}BeforeFirst;

private DAfterLast {param_name}AfterLast;

private DNone {param_name}None;
{End}


#============================================
#========== ADAPTER TO SET INTERNALS ========
#============================================

#========== apply_internals_initializer =======
Macro apply_internals_initializer
  Param
    param_name : String;
    redefined_internals_setter : redefined_internals_setter;
{Body}
macro.apply(new InternalsInitializer("{param_name}"){
{Indent: "\t"}
{redefined_internals_setter}
{End}
});
{End}

#========== redefined_internals_setter =========
Macro redefined_internals_setter
  Param
    name : String;
    macro_body_parts : init_string_builder, string_part, param_insert_part, eol_part, insert_macro_part, separator="\n";
    set_internals : set_internal;
{Body}
@Override
void set{name}(M{name} m{name}){

    {macro_body_parts}
    {set_internals}
}
{End}

#===================================================
#=============== MACRO / TEXT PARTS ================
#===================================================

#========= string_part =================
Macro string_part
  Param
    string : String;
    index_builder : String;
{Body}
sb{index_builder}.append("{string}");
{End}

#========= eol_part ===================
Macro eol_part
  Param
    index_builder : String;
{Body}
sb{index_builder}.append(LINE_SEPARATOR);
{End}

#========== param_insert_part ==========
Macro param_insert_part
  Param
    param_name : String;
    index_builder : String;
    context_arg : context_arg;
{Body}
sb{index_builder}.append(build{param_name}({context_arg}));
{End}

#========== indent_part ===========
Macro indent_part
    Param
        index_builder : String;
        index_indent : String;
{Body}
sb{index_builder}.append(applyIndent(sb{index_indent}.toString(), indentations.remove(indentations.size() - 1)));
{End}

#========== insert_macro_part ===============
Macro insert_macro_part
  Param
    name : String;
    index_builder : String;
    index_insert : String;
    macro_body_parts : init_string_builder, string_part, param_insert_part, eol_part, insert_macro_part;
    set_internals : set_internal;
{Body}
M{name} minsert_{index_insert} = new M{name}();
{macro_body_parts}
{set_internals}
sb{index_builder}.append(minsert_{index_insert}.build(null));
{End}

#========= init_string_builder =========
Macro init_string_builder
  Param
    index_builder : String;
{Body}
StringBuilder sb{index_builder} = new StringBuilder();
{End}

#========== set_internal ==================
Macro set_internal
  Param
    macro_name : String;
    param_name : String;
    context : String;
    set_params : param_ref, string_builder_build;
{Body}
m{macro_name}.set{param_name}({context}, {set_params});
{End}

#========== string_builder_build ==========
Macro string_builder_build
  Param
    index_builder : String;
{Body}
sb{index_builder}.toString()
{End}

#=========== param_ref ===========
Macro param_ref
  Param
    name : String;
    get_params : context_arg, context_name;
{Body}
get{name}({get_params})
{End}

#========= add_indent ===================
Macro add_indent
    Param
        macro_body_parts : init_string_builder, string_part, param_insert_part, eol_part, insert_macro_part;
{Body}
sbIndentation = new StringBuilder();
{macro_body_parts}
indentations.add(sbIndentation.toString());
{End}

#===================================================
#===================== OTHER =======================
#===================================================

#========== string_value ========
Macro string_value
  Param
    string : String;
{Body}
"{string}"
{End}

#=========== macro_arg ==========
Macro macro_arg
  Param
    name : String;
{Body}
list_{name}
{End}

#=========== string_arg =========
Macro string_arg
  Param
    name : String;
{Body}
field_{name}
{End}

#========== param_arg ==========
Macro param_arg
  Param
    name : String;
{Body}
p{name}
{End}

#=========== context_name =============
Macro context_name
  Param
    context_name : String;
{Body}
{context_name}
{End}

#======== context_param ============
Macro context_param
{Body}
Context context
{End}

#========= context_arg ============
Macro context_arg
{Body}
context
{End}

#=========== get_internal_tail ============
Macro get_internal_tail
{Body}
.get(context)
{End}

#========== string_param ==========
Macro string_param
  Param
    name : String;
{Body}
String p{name}
{End}


#===================================================
#===================== DIRECTIVES ==================
#===================================================

#=========== class_none ============
Macro class_none
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

class DNone
        extends Directive{

    DNone(String value) {

        super(value);
    }

    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(list_size == 0){
            return this.value;
        }

        return macro;
    }
}

{End}

#========== class_before_first =========
Macro class_before_first
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}

{package_declaration}

class DBeforeFirst
        extends Directive {

    DBeforeFirst(String value) {

        super(value);
    }

    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(index == 0){
            return this.value.concat(macro);
        }
        return macro;
    }
}

{End}

#========== class_after_last ==========
Macro class_after_last
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}

{package_declaration}

class DAfterLast
        extends Directive {

    DAfterLast(String value) {

        super(value);
    }

    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(index == list_size - 1){
            return macro.concat(this.value);
        }
        return macro;
    }
}
{End}

#======== class_separator ===========
Macro class_separator
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}

{package_declaration}

class DSeparator
        extends Directive {

    DSeparator(String value) {

        super(value);
    }

    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(index == list_size - 1){
            return macro;
        }

        return macro.concat(this.value);
    }
}
{End}


#=========================================================
#=====================  EXCEPTIONS =======================
#=========================================================

#============ object_macro_exception ===========
Macro ex_object_macro_exception
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}

{package_declaration}

public class ObjectMacroException
        extends RuntimeException{

    private ObjectMacroException(
            String message){

        super(message);

        if(message == null){
            throw new RuntimeException("message may not be null");
        }
    }

    private ObjectMacroException(
            String message,
            Throwable cause) {

        super(message, cause);

        if (message == null) {
            throw new RuntimeException("message may not be null");
        }

        if (cause == null) {
            throw new RuntimeException("cause may not be null");
        }
    }

    static ObjectMacroException incorrectType(
            String type,
            String param_name){


        return new ObjectMacroException(
                new MIncorrectType(type, param_name).toString());
    }

    static ObjectMacroException macroNull(
            Integer index,
            String paramName){

        return new ObjectMacroException(
                new MMacroNullInList(String.valueOf(index), paramName).toString());
    }

    static ObjectMacroException parameterNull(
            String paramName){

        return new ObjectMacroException(new MParameterNull(paramName).toString());
    }

    static ObjectMacroException cyclicReference(
            String macroName){

        return new ObjectMacroException(new MCyclicReference(macroName).toString());
    }

    static ObjectMacroException cannotModify(
            String macroName){

        return new ObjectMacroException(new MCannotModify(macroName).toString());
    }

}
{End}

#============ incorrect_type ===========
Macro ex_incorrect_type
  Param
    package_declaration : package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

public class MIncorrectType {

  private final String pType;
  private final String pParamName;
  private final MIncorrectType mIncorrectType = this;

  public MIncorrectType(String pType, String pParamName) {
    if(pType == null) throw new NullPointerException();
    this.pType = pType;
    if(pParamName == null) throw new NullPointerException();
    this.pParamName = pParamName;
  }

  String pType() {
    return this.pType;
  }

  String pParamName() {
    return this.pParamName;
  }

  private String rType() {
    return this.mIncorrectType.pType();
  }

  private String rParamName() {
    return this.mIncorrectType.pParamName();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(new MObjectMacroErrorHead().toString());
    sb.append(System.getProperty("line.separator"));
    sb.append(rType());
    sb.append(" was not expected in parameter '");
    sb.append(rParamName());
    sb.append("'.");
    sb.append(System.getProperty("line.separator"));
    return sb.toString();
  }

}
{End}

#============== ex_object_macro_error_head ===========
Macro ex_object_macro_error_head
  Param
    package_declaration : package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

class MObjectMacroErrorHead {

  MObjectMacroErrorHead() {
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("*** OBJECT MACRO ERROR ***");
    sb.append(System.getProperty("line.separator"));
    return sb.toString();
  }

}
{End}

#=============== ex_parameter_null ==============
Macro ex_parameter_null
  Param
    package_declaration : package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

public class MParameterNull {

  private final String pParamName;
  private final MParameterNull mParameterNull = this;

  public MParameterNull(String pParamName) {
    if(pParamName == null) throw new NullPointerException();
    this.pParamName = pParamName;
  }

  String pParamName() {
    return this.pParamName;
  }

  private String rParamName() {
    return this.mParameterNull.pParamName();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("Parameter '");
    sb.append(rParamName());
    sb.append("' cannot be null.");
    sb.append(System.getProperty("line.separator"));
    return sb.toString();
  }

}

{End}

#============ ex_macro_null_in_list ============
Macro ex_macro_null_in_list
  Param
    package_declaration : package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

public class MMacroNullInList {

  private final String pIndex;
  private final String pParamName;
  private final MMacroNullInList mMacroNullInList = this;

  public MMacroNullInList(String pIndex, String pParamName) {
    if(pIndex == null) throw new NullPointerException();
    this.pIndex = pIndex;
    if(pParamName == null) throw new NullPointerException();
    this.pParamName = pParamName;
  }

  String pIndex() {
    return this.pIndex;
  }

  String pParamName() {
    return this.pParamName;
  }

  private String rIndex() {
    return this.mMacroNullInList.pIndex();
  }

  private String rParamName() {
    return this.mMacroNullInList.pParamName();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("A macro is null at index ");
    sb.append(rIndex());
    sb.append(" in the list '");
    sb.append(rParamName());
    sb.append("'.");
    sb.append(System.getProperty("line.separator"));
    return sb.toString();
  }

}
{End}

#============ ex_cannot_modify ============
Macro ex_cannot_modify
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

public class MCannotModify {

  private final String pMacroName;
  private final MCannotModify mCannotModify = this;

  public MCannotModify(String pMacroName) {
    if(pMacroName == null) throw new NullPointerException();
    this.pMacroName = pMacroName;
  }

  String pMacroName() {
    return this.pMacroName;
  }

  private String rMacroName() {
    return this.mCannotModify.pMacroName();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(new MObjectMacroErrorHead().toString());
    sb.append(System.getProperty("line.separator"));
    sb.append("Instance of M");
    sb.append(rMacroName());
    sb.append(" cannot be updated after calling the method built.");
    sb.append(System.getProperty("line.separator"));
    return sb.toString();
  }

}
{End}

#============ ex_cyclic_reference ============

Macro ex_cyclic_reference
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

public class MCyclicReference {

  private final String pMacroName;
  private final MCyclicReference mCyclicReference = this;

  public MCyclicReference(String pMacroName) {
    if(pMacroName == null) throw new NullPointerException();
    this.pMacroName = pMacroName;
  }

  String pMacroName() {
    return this.pMacroName;
  }

  private String rMacroName() {
    return this.mCyclicReference.pMacroName();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(new MObjectMacroErrorHead().toString());
    sb.append(System.getProperty("line.separator"));
    sb.append("An instance of \\"");
    sb.append(rMacroName());
    sb.append("\\" is a cyclic reference to the same instance.");
    sb.append(System.getProperty("line.separator"));
    return sb.toString();
  }

}
{End}
