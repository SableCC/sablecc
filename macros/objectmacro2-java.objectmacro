# This file is part of SableCC ( http://sablecc.org ).
#
# See the NOTICE file distributed with this work for copyright information.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# ========== header ==========

Macro header
{Body}
/* This file was generated by SableCC's ObjectMacro. */
{End}

# ========== package_declaration ==========

Macro package_declaration
    Param
        package_name: String;
{Body}
package {package_name};
{End}

# ========== import_java_util ==========

Macro import_java_util
{Body}
import java.util.*;
{End}

# ========== context ==============

Macro context
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

public class Context {

}
{End}

# ========== internals_initializer =========

Macro internals_initializer
    Param
        package_declaration: package_declaration, before_first="\n";
        parent_internal_setters: parent_internals_setter, separator="\n\n";
{Body}
{Insert: header}
{package_declaration}

class InternalsInitializer {

    private final String _paramName;

    InternalsInitializer(String paramName) {
        this._paramName = paramName;
    }

{Indent: "\t"}
{parent_internal_setters}
{End}

    void setObjectMacroUserErrorHead(MObjectMacroUserErrorHead mObjectMacroUserErrorHead) {
        throw ObjectMacroException.incorrectType("MObjectMacroUserErrorHead", this._paramName);
    }

    void setUserErrorIncorrectType(MUserErrorIncorrectType mUserErrorIncorrectType) {
        throw ObjectMacroException.incorrectType("MUserErrorIncorrectType", this._paramName);
    }

    void setUserErrorMacroNullInList(MUserErrorMacroNullInList mUserErrorMacroNullInList) {
        throw ObjectMacroException.incorrectType("MUserErrorMacroNullInList", this._paramName);
    }

    void setUserErrorCyclicReference(MUserErrorCyclicReference mUserErrorCyclicReference) {
        throw ObjectMacroException.incorrectType("MUserErrorCyclicReference", this._paramName);
    }

    void setUserErrorParameterNull(MUserErrorParameterNull mUserErrorParameterNull) {
        throw ObjectMacroException.incorrectType("MUserErrorParameterNull", this._paramName);
    }

    void setUserErrorCannotModify(MUserErrorCannotModify mUserErrorCannotModify) {
        throw ObjectMacroException.incorrectType("MUserErrorCannotModify", this._paramName);
    }

    void setUserErrorVersionNull(MUserErrorVersionNull mUserErrorVersionNull) {
        throw ObjectMacroException.incorrectType("MUserErrorVersionNull", this._paramName);
    }

    void setUserErrorVersionsDifferent(MUserErrorVersionsDifferent mUserErrorVersionsDifferent) {
        throw ObjectMacroException.incorrectType("MUserErrorVersionsDifferent", this._paramName);
    }

    void setUserErrorInternalException(MUserErrorInternalException mUserErrorInternalException) {
        throw ObjectMacroException.incorrectType("MUserErrorInternalException", this._paramName);
    }

}
{End}

# ========== parent_internals_setter =========

Macro parent_internals_setter
    Param
        name: String;
{Body}
void set{name}(M{name} m{name}) {
    throw ObjectMacroException.incorrectType("M{name}", this._paramName);
}
{End}

# ============ cycle_detector =============

Macro cycle_detector_class
    Param
        package_declaration: package_declaration, before_first="\n";

{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

public class CycleDetector {

    private Macro receiver;

    private Set<Macro> visited;

    void detectCycle(
            Macro receiver,
            Macro added){

        this.visited = new LinkedHashSet<>();
        this.receiver = receiver;
        detectCycle(added);
    }

    private void detectCycle(
            Macro macro){

        if(this.visited.contains(macro)){
            return;
        }

        if(macro == this.receiver){
            throw ObjectMacroException.cyclicReference(macro.getClass().getSimpleName());
        }

        this.visited.add(macro);

        for(Macro child : macro.getChildren()){
            detectCycle(child);
        }
    }
}
{End}

# ========== super_macro ==========

Macro super_macro
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

public abstract class Macro {

    final static String LINE_SEPARATOR = System.getProperty("line.separator");

    CacheBuilder cacheBuilder = null;

    final Map<Context, CacheBuilder> cacheBuilders = new LinkedHashMap<>();

    final LinkedList<Macro> children = new LinkedList<>();

    static final CycleDetector cycleDetector = new CycleDetector();

    Macros macros;

    abstract String build(Context context);

    void apply(
            InternalsInitializer internalsInitializer){

        throw new RuntimeException("apply cannot be called here");
    }

    LinkedList<Macro> getChildren(){
        return this.children;
    }

    Macros getMacros(){
        return this.macros;
    }

    String applyIndent(
                String macro,
                String indent){

        StringBuilder sb = new StringBuilder();
        String[] lines = macro.split( "\\n");

        if(lines.length > 1){
            for(int i = 0; i < lines.length; i++){
                String line = lines[i];
                sb.append(indent).append(line);

                if(i < lines.length - 1){
                    sb.append(LINE_SEPARATOR);
                }
            }
        }
        else{
            sb.append(indent).append(macro);
        }

        return sb.toString();
    }
}
{End}

# =============== super_directive ==============

Macro super_directive
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

abstract class Directive {

    final String value;

    Directive(
            String value) {

        this.value = value;
    }

    abstract String apply(Integer index, String macro, Integer list_size);
}
{End}

# =============== class_internal_value =========

Macro class_internal_value
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

class InternalValue {

    private final List<Macro> macros;

    private DAfterLast dAfterLast;

    private DBeforeFirst dBeforeFirst;

    private DSeparator dSeparator;

    private DNone dNone;

    private final Context context;

    private String cache;

    InternalValue(
            List<Macro> macros,
            Context context){

        this.macros = macros;
        this.context = context;
    }

    String build(){

        if(this.cache != null){
            return this.cache;
        }

        StringBuilder sb = new StringBuilder();
        int i = 0;
        int nb_macros = this.macros.size();

        if(this.dNone != null){
            sb.append(this.dNone.apply(i, "", nb_macros));
        }

        for(Macro macro : this.macros){
            String expansion = macro.build(this.context);

            if(this.dBeforeFirst != null){
                expansion = dBeforeFirst.apply(i, expansion, nb_macros);
            }

            if(dAfterLast != null){
                expansion = dAfterLast.apply(i, expansion, nb_macros);
            }

            if(this.dSeparator != null){
                expansion = dSeparator.apply(i, expansion, nb_macros);
            }

            sb.append(expansion);
            i++;
        }

        this.cache = sb.toString();
        return this.cache;
    }

    void setNone(
                DNone none){

        this.dNone = none;
    }

    void setBeforeFirst(
            DBeforeFirst dBeforeFirst){

        this.dBeforeFirst = dBeforeFirst;
    }

    void setAfterLast(
            DAfterLast dAfterLast){

        this.dAfterLast = dAfterLast;
    }

    void setSeparator(
            DSeparator dSeparator){

        this.dSeparator = dSeparator;
    }
}
{End}

# =============== class_cache_builder =========

Macro class_cache_builder
    Param
        package_declaration: package_declaration,before_first="\n";
{Body}
{Insert: header}
{package_declaration}

class CacheBuilder {

    private String expansion = null;

    public String getExpansion() {
        return expansion;
    }

    public void setExpansion(
            String expansion) {

        this.expansion = expansion;
    }
}
{End}

# ============ version_enumeration =========

Macro version_enumeration
    Param
        package_declaration: package_declaration, before_first="\n";
        versions: plain_text, separator=", ";
{Body}
{Insert: header}
{package_declaration}

public enum VERSIONS{
{Indent: "\t"}
{versions}
{End}
}
{End}

# ======================================================
# ===================== FACTORIES ======================
# ======================================================

# ============== macro_factory ============

Macro macro_factory
    Param
        default_version: version, none="null";
        package_declaration: package_declaration, before_first="\n";
        new_macro_methods: macro_creator_method, separator="\n\n", before_first="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

public class Macros{
    private VERSIONS version;

    public Macros(
            VERSIONS version){

        if(version == null){
            throw ObjectMacroException.versionNull();
        }

        this.version = version;
    }

    public Macros(){
        this.version = {default_version};
    }
{Indent: "\t"}
{new_macro_methods}
{End}
}
{End}

# ========== macro_creator_method ===========

Macro macro_creator_method
    Param
        class_name: String;
        args: param_arg, separator=", ", after_last=", ";
        parameters: string_param, separator=", ";
        version_factory: switch_version(class_name, args), before_first="\n", none="m{class_name} = new M{class_name}({args}this);";
{Body}
public M{class_name} new{class_name}({parameters}){
    M{class_name} m{class_name};

{Indent: "\t"}
{version_factory}
{End}

    return m{class_name};
}
{End}

# ============ switch_version ===========

Macro switch_version
    Param
        version_cases: macro_case_init(class_name, args), separator="\n";
    Internal
        class_name: String;
        args: param_arg;
{Body}
switch(this.version){
{Indent: "\t"}
{version_cases}
{End}
    default :
        throw new RuntimeException("unknown version");
}
{End}

# ============ macro_case_init ==========

Macro macro_case_init
    Param
        version: String;
        version_class_name: String;
    Internal
        class_name: String;
        args: param_arg;
{Body}
case {version} :
    m{class_name} = new M{version_class_name}({args} this);
    break;
{End}

# =========== version =============

Macro version
    Param
        default_case: String;
{Body}
VERSIONS.{default_case}
{End}

# ======================================================
# ===================== MACRO CLASS ====================
# ======================================================

# ========== macro ==========

Macro macro
    Param
        class_name: String;
        parent_class: String;
        package_declaration: package_declaration, before_first="\n";
        fields: param_macro_field, param_string_field, internal_macro_field, internal_string_field, directive_fields, separator="\n\n", before_first="\n";
        constructor: constructor(class_name), before_first="\n";
        setters: single_add, add_all, abstract_type_verifier, type_verifier, param_string_setter, internal_string_setter, internal_macro_setter, separator="\n\n", before_first="\n";
        builders: param_string_ref_builder, param_macro_ref_builder, internal_macro_ref_builder, separator="\n\n", before_first="\n";
        getters: param_string_ref, param_macro_ref, internal_macro_ref, separator="\n\n", before_first="\n";
        init_internals_methods: init_internals_method, separator="\n\n";
        init_directives: init_directives, separator="\n\n", before_first="\n";
        redefined_apply_initializer: redefined_apply_initializer(class_name);
        macro_builders: macro_builder, abstract_builder, empty_builder_with_context, separator="\n\n", before_first="\n";
        abstract: abstract;
        applied_version: applied_version, before_first="\n";
        init_macros_method: set_macros_method, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

{Insert: import_java_util}
{applied_version}
public {abstract} class M{class_name} extends M{parent_class}{
{Indent: "\t"}
{fields}
{constructor}
{setters}
{builders}
{getters}
{init_internals_methods}
{init_directives}
{redefined_apply_initializer}
{macro_builders}

{init_macros_method}
{End}
}
{End}

# ============ applied_version =========

Macro applied_version
    Param
        versions: plain_text, separator=", ";
{Body}
// Class applied to version(s) : {versions}
{End}

# ======================================================
# ===================== CONSTRUCTOR ====================
# ======================================================

# ========== constructor ==========

Macro constructor
    Param
        field_initializers: set_param, init_macro_param, init_macro_internal, init_string_internal, set_macros_call("macros"), before_first="\n", separator="\n";
        parameters: string_param, macros_param("macros"), separator=", ";
        internal_values_initializers: init_internal_value, before_first="\n", separator="\n";
        super: super_call, before_first="\n";
    Internal
        class_name: String;
{Body}
M{class_name}({parameters}){
{Indent: "\t"}
{super}
{field_initializers}
{internal_values_initializers}
{End}
}
{End}

# ========== init_macro_internal ===========

Macro init_macro_internal
    Param
        name: String;
{Body}
this.list_{name} = new LinkedHashMap<>();
{End}

# ========== init_macro_param ===========

Macro init_macro_param
    Param
        name: String;
{Body}
this.list_{name} = new LinkedList<>();
{End}

# ========== init_string_internal ===========

Macro init_string_internal
    Param
        name: String;
{Body}
this.field_{name} = new LinkedHashMap<>();
{End}

# ========== init_internal_value ============

Macro init_internal_value
    Param
        param_name: String;
{Body}
this.{param_name}Value = new InternalValue(this.list_{param_name}, this.{param_name}Context);
{End}

# ========== set_param ==========

Macro set_param
    Param
        name: String;
        set_param: param_arg;
{Body}
this.setP{name}({set_param});
{End}

# ========== set_macros_call ==========

Macro set_macros_call
    Internal
        macros_param_name: String;
{Body}
this.setMacros({macros_param_name});
{End}

# ========== super_call ========

Macro super_call
{Body}
super();
{End}

# ================================================================
# ===================== MACRO FUNCTIONS ==========================
# ================================================================

# ========= single_add ===========

Macro single_add
    Param
        referenced_macro_name: String;
        current_macro_name: String;
        param_name: String;
{Body}
public void add{param_name}(M{referenced_macro_name} macro){
    if(macro == null){
        throw ObjectMacroException.parameterNull("{param_name}");
    }
{Indent: "\t"}
{Insert: is_built(current_macro_name)}

{Insert: factory_comparison("macro")}
{End}

    this.list_{param_name}.add(macro);
    this.children.add(macro);
    Macro.cycleDetector.detectCycle(this, macro);
}
{End}

# ============= add_all ==============

Macro add_all
    Param
        macro_name: String;
        param_name: String;
{Body}
public void addAll{param_name}(
                List<Macro> macros){

    if(macros == null){
        throw ObjectMacroException.parameterNull("{param_name}");
    }
{Indent: "\t"}
{Insert: is_built(macro_name)}

int i = 0;

for(Macro macro : macros) {
    if(macro == null) {
        throw ObjectMacroException.macroNull(i, "{param_name}");
    }

{Indent: "\t"}
{Insert: factory_comparison("macro")}
{End}

    this.verifyType{param_name}(macro);
    this.list_{param_name}.add(macro);
    this.children.add(macro);
    Macro.cycleDetector.detectCycle(this, macro);

    i++;
}

{End}
}
{End}

# ============= type_verifier ===================

Macro type_verifier
    Param
        param_name: String;
        type_verification: apply_internals_initializer(param_name);
        override: override;
{Body}
{override}
void verifyType{param_name} (Macro macro) {
{Indent: "\t"}
{type_verification}
{End}
}
{End}

# ============= abstract_type_verifier ========

Macro abstract_type_verifier
    Param
        param_name: String;
{Body}
abstract void verifyType{param_name}(Macro macro);
{End}

# ============= factory_comparison ==============

Macro factory_comparison
    Internal
        var_name: String;
{Body}
if(this.getMacros() != {var_name}.getMacros()){
    throw ObjectMacroException.diffMacros();
}
{End}

# =========== is_built ===========

Macro is_built
    Internal
        macro_name: String;
{Body}
if(this.cacheBuilder != null){
    throw ObjectMacroException.cannotModify("{macro_name}");
}
{End}

# =========== param_string_ref_builder =============

Macro param_string_ref_builder
    Param
    name: String;
    context_param: context_param;
    get_internal_tail: get_internal_tail;
{Body}
String build{name}({context_param}){

    return this.field_{name}{get_internal_tail};
}
{End}

# ========== param_macro_ref_builder ==================

Macro param_macro_ref_builder
    Param
        name: String;
        context_name: plain_text, none="context";
{Body}
private String build{name}(){
    StringBuilder sb = new StringBuilder();
    Context local_context = {context_name};
    List<Macro> macros = this.list_{name};

    int i = 0;
    int nb_macros = macros.size();
    String expansion = null;

    if(this.{name}None != null){
        sb.append(this.{name}None.apply(i, "", nb_macros));
    }

    for(Macro macro : macros){
        expansion = macro.build(local_context);

        if(this.{name}BeforeFirst != null){
            expansion = this.{name}BeforeFirst.apply(i, expansion, nb_macros);
        }

        if(this.{name}AfterLast != null){
            expansion = this.{name}AfterLast.apply(i, expansion, nb_macros);
        }

        if(this.{name}Separator != null){
            expansion = this.{name}Separator.apply(i, expansion, nb_macros);
        }

        sb.append(expansion);
        i++;
    }

    return sb.toString();
}
{End}

# =========== internal_macro_ref_builder ================

Macro internal_macro_ref_builder
    Param
        internal_name: String;
{Body}
private String build{internal_name}(Context context){

    InternalValue macros = this.list_{internal_name}.get(context);
    return macros.build();
}
{End}

# ========= internal_macro_setter =========

Macro internal_macro_setter
    Param
        param_name: String;
{Body}
void set{param_name}(
            Context context,
            InternalValue internal_value) {

    if(internal_value == null){
        throw new RuntimeException("macros cannot be null");
    }

    this.list_{param_name}.put(context, internal_value);
}
{End}

# =========== param_string_setter =========

Macro param_string_setter
    Param
        name: String;
        string_param: string_param;
        param_arg: param_arg;
{Body}
private void setP{name}( {string_param} ){
    if({param_arg} == null){
        throw ObjectMacroException.parameterNull("{name}");
    }

    this.field_{name} = {param_arg};
}
{End}

# ========== param_macro_ref ==============

Macro param_macro_ref
    Param
        name: String;
{Body}
private InternalValue get{name}(){
    return this.{name}Value;
}
{End}

# ========== internal_macro_ref ===========

Macro internal_macro_ref
    Param
        param_name: String;
{Body}
private InternalValue get{param_name}(Context context){
    return this.list_{param_name}.get(context);
}
{End}

# ========== param_string_ref ==============

Macro param_string_ref
    Param
        name: String;
        context_param: context_param;
        get_internal_tail: get_internal_tail;
{Body}
String get{name}({context_param}){

    return this.field_{name}{get_internal_tail};
}
{End}

# ========= internal_string_setter =========

Macro internal_string_setter
    Param
        name: String;
{Body}
void set{name}(
        Context context,
        String value) {

    if(value == null){
        throw new RuntimeException("value cannot be null here");
    }

    this.field_{name}.put(context, value);
}
{End}

# ========= init_internals_method ========

Macro init_internals_method
    Param
        param_name: String;
        apply_internals_initializer: apply_internals_initializer(param_name), separator = "\n";
{Body}
private void init{param_name}Internals(Context context){
    for(Macro macro : this.list_{param_name}){
{Indent: "\t\t"}
{apply_internals_initializer}
{End}
    }
}
{End}

# =========== init_directives ===========

Macro init_directives
    Param
        param_name: String;
        new_directives: new_directive(param_name);
{Body}
private void init{param_name}Directives(){
{Indent: "\t"}
{new_directives}
{End}
}
{End}

# =========== new_directive ===========

Macro new_directive
    Param
        directive_name: String;
        index_builder: String;
        text_parts: string_part, param_insert_part, eol_part, insert_macro_part, separator="\n";
    Internal
        param_name: String;
{Body}
StringBuilder sb{index_builder} = new StringBuilder();
{text_parts}
this.{param_name}{directive_name} = new D{directive_name}(sb{index_builder}.toString());
this.{param_name}Value.set{directive_name}(this.{param_name}{directive_name});
{End}

# =========== set_macros_method ==========

Macro set_macros_method
{Body}
private void setMacros(Macros macros){
    if(macros == null){
        throw new InternalException("macros cannot be null");
    }

    this.macros = macros;
}
{End}

# ============================================
# ============== MACRO BUILDER ===============
# ============================================

# ========== macro_builder =======

Macro macro_builder
    Param
        context_param: context_param;
        context_cache_builder: context_cache_builder, none="this.cacheBuilder";
        new_cache_builder: new_cache_builder, none="this.cacheBuilder = cache_builder";
        directives_calls: init_directive_call, separator="\n";
        internals_calls: init_internals_call, separator="\n";
        macro_body_parts: init_string_builder, string_part, param_insert_part,  eol_part, insert_macro_part, add_indent, indent_part, separator="\n";
        public: public, after_last=" ";
        override: override;
{Body}
{override}
{public}String build({context_param}){

    CacheBuilder cache_builder = {context_cache_builder};

    if(cache_builder == null){
        cache_builder = new CacheBuilder();
    }
    else if(cache_builder.getExpansion() == null){
        throw new InternalException("Cycle detection detected lately");
    }
    else{
        return cache_builder.getExpansion();
    }
    {new_cache_builder};
    List<String> indentations = new LinkedList<>();
    StringBuilder sbIndentation = new StringBuilder();

{Indent: "\t"}
{directives_calls}

{internals_calls}
{End}

    StringBuilder sb0 = new StringBuilder();

{Indent: "\t"}
{macro_body_parts}
{End}

    cache_builder.setExpansion(sb0.toString());
    return sb0.toString();
}
{End}

Macro init_directive_call
    Param
        param_name: String;
{Body}
init{param_name}Directives();
{End}

Macro init_internals_call
    Param
        param_name: String;
        context_arg: context_arg, none="null";
{Body}
init{param_name}Internals({context_arg});
{End}

# ============ abstract_builder ===========

Macro abstract_builder
{Body}
public abstract String build();
{End}

# ============ empty_builder_with_context ============

Macro empty_builder_with_context
{Body}
@Override
String build(Context context) {
    return build();
}
{End}

# ========== context_cache_builder =======

Macro context_cache_builder
{Body}
this.cacheBuilders.get(context)
{End}

# ========== new_cache_builder =========

Macro new_cache_builder
{Body}
this.cacheBuilders.put(context, cache_builder)
{End}

# ========= redefined_apply_initializer =======

Macro redefined_apply_initializer
    Internal
        class_name: String;
{Body}
@Override
void apply(
        InternalsInitializer internalsInitializer){

    internalsInitializer.set{class_name}(this);
}
{End}

# ===================================================
# ================= MACRO FIELDS ====================
# ===================================================

# ========== param_macro_field ==========

Macro param_macro_field
    Param
        param_name: String;
{Body}
final List<Macro> list_{param_name};

{Insert: context_field(param_name)}

{Insert: internal_macros_value_field(param_name)}
{End}

# ========== param_string_field ==========

Macro param_string_field
    Param
        name: String;
{Body}
String field_{name};
{End}

# ========== internal_macro_field ==========

Macro internal_macro_field
    Param
        name: String;
{Body}
private Map<Context, InternalValue> list_{name} = new LinkedHashMap<>();
{End}

# ========== internal_string_field ==========

Macro internal_string_field
    Param
        name: String;
{Body}
private Map<Context, String> field_{name} = new LinkedHashMap<>();
{End}

# ========== context_field =========

Macro context_field
    Internal
        param_name: String;
{Body}
final Context {param_name}Context = new Context();
{End}

# =========== internal_macros_value_field ========

Macro internal_macros_value_field
    Internal
        param_name: String;
{Body}
final InternalValue {param_name}Value;
{End}

# ========== directive_fields ==========

Macro directive_fields
    Param
        param_name: String;
{Body}
private DSeparator {param_name}Separator;

private DBeforeFirst {param_name}BeforeFirst;

private DAfterLast {param_name}AfterLast;

private DNone {param_name}None;
{End}


# ============================================
# ========== ADAPTER TO SET INTERNALS ========
# ============================================

# ========== apply_internals_initializer =====

Macro apply_internals_initializer
    Param
        redefined_internals_setter: redefined_internals_setter, separator="\n\n";
    Internal
        param_name: String;
{Body}
macro.apply(new InternalsInitializer("{param_name}"){
{Indent: "\t"}
{redefined_internals_setter}
{End}
});
{End}

# ========== redefined_internals_setter =========

Macro redefined_internals_setter
    Param
        macro_name: String;
        text_parts: init_string_builder, string_part, param_insert_part, eol_part, insert_macro_part, separator="\n";
        set_internals: set_internal(macro_name), separator="\n";
{Body}
@Override
void set{macro_name}(M{macro_name} m{macro_name}){

    {text_parts}
    {set_internals}
}
{End}

# ===================================================
# =============== MACRO / TEXT PARTS ================
# ===================================================

# ========= string_part =================

Macro string_part
    Param
        string: String;
        index_builder: String;
{Body}
sb{index_builder}.append("{string}");
{End}

# ========= eol_part ===================

Macro eol_part
    Param
        index_builder: String;
{Body}
sb{index_builder}.append(LINE_SEPARATOR);
{End}

# ========== param_insert_part ==========

Macro param_insert_part
    Param
        param_name: String;
        index_builder: String;
        context_arg: context_arg;
{Body}
sb{index_builder}.append(build{param_name}({context_arg}));
{End}

# ========== indent_part ===========

Macro indent_part
    Param
        index_builder: String;
        index_indent: String;
{Body}
sb{index_builder}.append(applyIndent(sb{index_indent}.toString(), indentations.remove(indentations.size() - 1)));
{End}

# ========== insert_macro_part ===============

Macro insert_macro_part
    Param
        name: String;
        index_builder: String;
        index_insert: String;
        macro_body_parts: init_string_builder, string_part, param_insert_part, eol_part, insert_macro_part, separator="\n";
        set_internals: set_internal(index_insert), separator="\n";
{Body}
M{name} m{index_insert} = this.getMacros().new{name}();
{macro_body_parts}
{set_internals}
sb{index_builder}.append(m{index_insert}.build(null));
{End}

# ========= init_string_builder =========

Macro init_string_builder
    Param
        index_builder: String;
{Body}
StringBuilder sb{index_builder} = new StringBuilder();
{End}

# ========== set_internal ==================

Macro set_internal
    Param
        param_name: String;
        context: String;
        set_params: param_ref, string_builder_build;
    Internal
        var_name: String;
{Body}
m{var_name}.set{param_name}({context}, {set_params});
{End}

# ========== string_builder_build ==========

Macro string_builder_build
    Param
        index_builder: String;
{Body}
sb{index_builder}.toString()
{End}

# =========== param_ref ===========

Macro param_ref
    Param
        name: String;
        get_params: context_arg, plain_text;
{Body}
get{name}({get_params})
{End}

# ========= add_indent ===================

Macro add_indent
    Param
        index_builder: String;
        indent_parts: init_string_builder, string_part, param_insert_part, eol_part, insert_macro_part, separator="\n";
{Body}
StringBuilder sb{index_builder} = new StringBuilder();
{indent_parts}
indentations.add(sb{index_builder}.toString());
{End}

# ===================================================
# ===================== OTHER =======================
# ===================================================

# ========== string_value ========

Macro string_value
    Param
        string: String;
{Body}
"{string}"
{End}

# =========== macro_arg ==========

Macro macro_arg
    Param
        name: String;
{Body}
list_{name}
{End}

# =========== string_arg =========

Macro string_arg
    Param
        name: String;
{Body}
field_{name}
{End}

# ========== param_arg ==========

Macro param_arg
    Param
        name: String;
{Body}
p{name}
{End}

# =========== plain_text =============

Macro plain_text
    Param
        plain_text: String;
{Body}
{plain_text}
{End}

# ======== context_param ============

Macro context_param
{Body}
Context context
{End}

# ========= context_arg ============

Macro context_arg
{Body}
context
{End}

# =========== get_internal_tail ============

Macro get_internal_tail
{Body}
.get(context)
{End}

# ========== string_param ==========

Macro string_param
    Param
    name: String;
{Body}
String p{name}
{End}

# ========== abstract ===========

Macro abstract
{Body}
abstract
{End}

# ========== macros_param ========

Macro macros_param
    Internal
        name: String;
{Body}
Macros {name}
{End}

# ========= public =============

Macro public
{Body}
public
{End}

# ========= override ============

Macro override
{Body}
@Override
{End}

# ===================================================
# ===================== DIRECTIVES ==================
# ===================================================

# =========== class_none ============

Macro class_none
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

class DNone
        extends Directive{

    DNone(String value) {

        super(value);
    }

    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(list_size == 0){
            return this.value;
        }

        return macro;
    }
}

{End}

# ========== class_before_first =========

Macro class_before_first
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}

{package_declaration}

class DBeforeFirst
        extends Directive {

    DBeforeFirst(String value) {

        super(value);
    }

    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(index == 0){
            return this.value.concat(macro);
        }
        return macro;
    }
}

{End}

# ========== class_after_last ==========

Macro class_after_last
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}

{package_declaration}

class DAfterLast
        extends Directive {

    DAfterLast(String value) {

        super(value);
    }

    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(index == list_size - 1){
            return macro.concat(this.value);
        }
        return macro;
    }
}
{End}

# ======== class_separator ===========

Macro class_separator
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}

{package_declaration}

class DSeparator
        extends Directive {

    DSeparator(String value) {

        super(value);
    }

    @Override
    String apply(
            Integer index,
            String macro,
            Integer list_size) {

        if(index == list_size - 1){
            return macro;
        }

        return macro.concat(this.value);
    }
}
{End}


# =========================================================
# =====================  EXCEPTIONS =======================
# =========================================================

# ============ ex_internal_exception ===========

Macro ex_internal_exception
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}

public class InternalException
        extends RuntimeException{

    InternalException(
            String message){

        super(message);

        if(message == null){
            throw new RuntimeException("message may not be null");
        }
    }

    InternalException(
            String message,
            Throwable cause) {

        super(new MUserErrorInternalException(message).build(), cause);

        if (message == null) {
            throw new RuntimeException("message may not be null");
        }

        if (cause == null) {
            throw new RuntimeException("cause may not be null");
        }
    }
}
{End}

# ============ object_macro_exception ===========

Macro ex_object_macro_exception
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}

{package_declaration}

public class ObjectMacroException
        extends RuntimeException{

    private ObjectMacroException(
            String message){

        super(message);

        if(message == null){
            throw new RuntimeException("message may not be null");
        }
    }

    private ObjectMacroException(
            String message,
            Throwable cause) {

        super(message, cause);

        if (message == null) {
            throw new RuntimeException("message may not be null");
        }

        if (cause == null) {
            throw new RuntimeException("cause may not be null");
        }
    }

    static ObjectMacroException incorrectType(
            String type,
            String param_name){


        return new ObjectMacroException(
                new MUserErrorIncorrectType(type, param_name).build());
    }

    static ObjectMacroException macroNull(
            Integer index,
            String paramName){

        return new ObjectMacroException(
                new MUserErrorMacroNullInList(String.valueOf(index), paramName).build());
    }

    static ObjectMacroException parameterNull(
            String paramName){

        return new ObjectMacroException(new MUserErrorParameterNull(paramName).build());
    }

    static ObjectMacroException cyclicReference(
            String macroName){

        return new ObjectMacroException(new MUserErrorCyclicReference(macroName).build());
    }

    static ObjectMacroException cannotModify(
            String macroName){

        return new ObjectMacroException(new MUserErrorCannotModify(macroName).build());
    }

    static ObjectMacroException versionNull(){
        return new ObjectMacroException(new MUserErrorVersionNull().build());
    }

    static ObjectMacroException diffMacros(){
        return new ObjectMacroException(new MUserErrorVersionsDifferent().build());
    }
}
{End}

# ============ ex_incorrect_type ===========

Macro ex_incorrect_type
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

class MUserErrorIncorrectType extends Macro{

       private String field_Type;

       private String field_ParamName;

       public MUserErrorIncorrectType(
                    String pType,
                    String pParamName){

           this.setPType(pType);
           this.setPParamName(pParamName);
       }

       private void setPType( String pType ){
           if(pType == null){
               throw ObjectMacroException.parameterNull("Type");
           }

           this.field_Type = pType;
       }

       private void setPParamName( String pParamName ){
           if(pParamName == null){
               throw ObjectMacroException.parameterNull("ParamName");
           }

           this.field_ParamName = pParamName;
       }

       private String buildType(){

           return this.field_Type;
       }

       private String buildParamName(){

           return this.field_ParamName;
       }

       private String getType(){

           return this.field_Type;
       }

       private String getParamName(){

           return this.field_ParamName;
       }

       @Override
       void apply(
               InternalsInitializer internalsInitializer){

           internalsInitializer.setUserErrorIncorrectType(this);
       }

       public String build(){

           CacheBuilder cache_builder = this.cacheBuilder;

           if(cache_builder == null){
               cache_builder = new CacheBuilder();
           }
           else{
               return cache_builder.getExpansion();
           }
           this.cacheBuilder = cache_builder;
           List<String> indentations = new LinkedList<>();
           StringBuilder sbIndentation = new StringBuilder();

           StringBuilder sb0 = new StringBuilder();

           MObjectMacroUserErrorHead minsert_1 = new MObjectMacroUserErrorHead();

           sb0.append(minsert_1.build(null));
           sb0.append(LINE_SEPARATOR);
           sb0.append(LINE_SEPARATOR);
           sb0.append(buildType());
           sb0.append(" was not expected in parameter '");
           sb0.append(buildParamName());
           sb0.append("'.");

           cache_builder.setExpansion(sb0.toString());
           return sb0.toString();
       }

       @Override
       String build(Context context) {
           return build();
       }
   }
{End}

# ============== ex_object_macro_error_head ===========

Macro ex_object_macro_error_head
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

class MObjectMacroUserErrorHead extends Macro{

    MObjectMacroUserErrorHead(){

    }

    @Override
    void apply(
            InternalsInitializer internalsInitializer){

        internalsInitializer.setObjectMacroUserErrorHead(this);
    }

    public String build(){

        CacheBuilder cache_builder = this.cacheBuilder;

        if(cache_builder == null){
            cache_builder = new CacheBuilder();
        }
        else{
            return cache_builder.getExpansion();
        }
        this.cacheBuilder = cache_builder;
        List<String> indentations = new LinkedList<>();
        StringBuilder sbIndentation = new StringBuilder();

        StringBuilder sb0 = new StringBuilder();

        sb0.append("*** OBJECT MACRO ERROR ***");

        cache_builder.setExpansion(sb0.toString());
        return sb0.toString();
    }


    @Override
    String build(Context context) {
        return build();
    }


}
{End}

# =============== ex_parameter_null ==============

Macro ex_parameter_null
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

class MUserErrorParameterNull extends Macro{

    private String field_ParamName;

    public MUserErrorParameterNull(String pParamName){
        this.setPParamName(pParamName);
    }

    private void setPParamName( String pParamName ){
        if(pParamName == null){
            throw ObjectMacroException.parameterNull("ParamName");
        }

        this.field_ParamName = pParamName;
    }

    private String buildParamName(){

        return this.field_ParamName;
    }

    private String getParamName(){

        return this.field_ParamName;
    }

    @Override
    void apply(
            InternalsInitializer internalsInitializer){

        internalsInitializer.setUserErrorParameterNull(this);
    }

    public String build(){

        CacheBuilder cache_builder = this.cacheBuilder;

        if(cache_builder == null){
            cache_builder = new CacheBuilder();
        }
        else{
            return cache_builder.getExpansion();
        }
        this.cacheBuilder = cache_builder;
        List<String> indentations = new LinkedList<>();
        StringBuilder sbIndentation = new StringBuilder();

        StringBuilder sb0 = new StringBuilder();

        MObjectMacroUserErrorHead minsert_1 = new MObjectMacroUserErrorHead();

        sb0.append(minsert_1.build(null));
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("Parameter '");
        sb0.append(buildParamName());
        sb0.append("' cannot be null.");

        cache_builder.setExpansion(sb0.toString());
        return sb0.toString();
    }

    @Override
    String build(Context context) {
        return build();
    }
}

{End}

# ============ ex_macro_null_in_list ============

Macro ex_macro_null_in_list
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

class MUserErrorMacroNullInList extends Macro{

    private String field_Index;

    private String field_ParamName;

    public MUserErrorMacroNullInList(String pIndex, String pParamName){

        this.setPIndex(pIndex);
        this.setPParamName(pParamName);

    }

    private void setPIndex( String pIndex ){
        if(pIndex == null){
            throw ObjectMacroException.parameterNull("Index");
        }

        this.field_Index = pIndex;
    }

    private void setPParamName( String pParamName ){
        if(pParamName == null){
            throw ObjectMacroException.parameterNull("ParamName");
        }

        this.field_ParamName = pParamName;
    }

    private String buildIndex(){

        return this.field_Index;
    }

    private String buildParamName(){

        return this.field_ParamName;
    }

    private String getIndex(){

        return this.field_Index;
    }

    private String getParamName(){

        return this.field_ParamName;
    }

    @Override
    void apply(
             InternalsInitializer internalsInitializer){

        internalsInitializer.setUserErrorMacroNullInList(this);
    }


    public String build(){

        CacheBuilder cache_builder = this.cacheBuilder;

        if(cache_builder == null){
            cache_builder = new CacheBuilder();
        }
        else{
            return cache_builder.getExpansion();
        }
        this.cacheBuilder = cache_builder;
        List<String> indentations = new LinkedList<>();
        StringBuilder sbIndentation = new StringBuilder();

        StringBuilder sb0 = new StringBuilder();

        MObjectMacroUserErrorHead minsert_1 = new MObjectMacroUserErrorHead();

        sb0.append(minsert_1.build(null));
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("A macro is null at index ");
        sb0.append(buildIndex());
        sb0.append(" in the list '");
        sb0.append(buildParamName());
        sb0.append("'.");

        cache_builder.setExpansion(sb0.toString());
        return sb0.toString();
    }


    @Override
    String build(Context context) {
        return build();
    }
}
{End}

# ============ ex_cannot_modify ============

Macro ex_cannot_modify
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

class MUserErrorCannotModify extends Macro{

    private String field_MacroName;

    public MUserErrorCannotModify(String pMacroName){

        this.setPMacroName(pMacroName);
    }

    private void setPMacroName( String pMacroName ){
        if(pMacroName == null){
            throw ObjectMacroException.parameterNull("MacroName");
        }

        this.field_MacroName = pMacroName;
    }

    private String buildMacroName(){

        return this.field_MacroName;
    }

    private String getMacroName(){

        return this.field_MacroName;
    }

    @Override
    void apply(
         InternalsInitializer internalsInitializer){

        internalsInitializer.setUserErrorCannotModify(this);
    }

    public String build(){

        CacheBuilder cache_builder = this.cacheBuilder;

        if(cache_builder == null){
            cache_builder = new CacheBuilder();
        }
        else{
            return cache_builder.getExpansion();
        }
        this.cacheBuilder = cache_builder;
        List<String> indentations = new LinkedList<>();
        StringBuilder sbIndentation = new StringBuilder();

        StringBuilder sb0 = new StringBuilder();

        MObjectMacroUserErrorHead minsert_1 = new MObjectMacroUserErrorHead();

        sb0.append(minsert_1.build(null));
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("Instance of M");
        sb0.append(buildMacroName());
        sb0.append(" cannot be updated after the macro has been built.");

        cache_builder.setExpansion(sb0.toString());
        return sb0.toString();
    }


    @Override
    String build(Context context) {
        return build();
    }
}
{End}

# ============ ex_cyclic_reference ============

Macro ex_cyclic_reference
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

class MUserErrorCyclicReference extends Macro{

    private String field_MacroName;

    public MUserErrorCyclicReference(String pMacroName){

        this.setPMacroName(pMacroName);
    }

    private void setPMacroName( String pMacroName ){
        if(pMacroName == null){
            throw ObjectMacroException.parameterNull("MacroName");
        }

        this.field_MacroName = pMacroName;
    }

    private String buildMacroName(){

        return this.field_MacroName;
    }

    private String getMacroName(){

        return this.field_MacroName;
    }

    @Override
    void apply(
            InternalsInitializer internalsInitializer){

        internalsInitializer.setUserErrorCyclicReference(this);
    }

    public String build(){

        CacheBuilder cache_builder = this.cacheBuilder;

        if(cache_builder == null){
            cache_builder = new CacheBuilder();
        }
        else{
            return cache_builder.getExpansion();
        }
        this.cacheBuilder = cache_builder;
        List<String> indentations = new LinkedList<>();
        StringBuilder sbIndentation = new StringBuilder();

        StringBuilder sb0 = new StringBuilder();

        MObjectMacroUserErrorHead minsert_1 = new MObjectMacroUserErrorHead();

        sb0.append(minsert_1.build(null));
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("An instance of \"");
        sb0.append(buildMacroName());
        sb0.append("\" is a cyclic reference to the same instance.");

        cache_builder.setExpansion(sb0.toString());
        return sb0.toString();
    }


    @Override
    String build(Context context) {
        return build();
    }
}
{End}

# ============ ex_version_null ============

Macro ex_version_null
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

public class MUserErrorVersionNull extends Macro{

    public MUserErrorVersionNull(){

    }

    @Override
    void apply(
         InternalsInitializer internalsInitializer){

        internalsInitializer.setUserErrorVersionNull(this);
    }

    public String build(){

        CacheBuilder cache_builder = this.cacheBuilder;

        if(cache_builder == null){
            cache_builder = new CacheBuilder();
        }
        else{
            return cache_builder.getExpansion();
        }
        this.cacheBuilder = cache_builder;
        List<String> indentations = new LinkedList<>();
        StringBuilder sbIndentation = new StringBuilder();

        StringBuilder sb0 = new StringBuilder();

        sb0.append("The version may not be null.");

        cache_builder.setExpansion(sb0.toString());
        return sb0.toString();
    }


    @Override
    String build(Context context) {
        return build();
    }
}
{End}

# ============ macro_internal_exception ===========

Macro macro_internal_exception
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

class MUserErrorInternalException extends Macro{

    private String field_StackTrace;

    private String field_Message;

    public MUserErrorInternalException(String pMessage){

        this.setPMessage(pMessage);
    }

    private void setPMessage( String pMessage ){
        if(pMessage == null){
            throw ObjectMacroException.parameterNull("Message");
        }

        this.field_Message = pMessage;
    }

    private String buildMessage(){

        return this.field_Message;
    }

    private String getMessage(){

        return this.field_Message;
    }

    @Override
    void apply(
             InternalsInitializer internalsInitializer){

        internalsInitializer.setUserErrorInternalException(this);
    }


    public String build(){

        CacheBuilder cache_builder = this.cacheBuilder;

        if(cache_builder == null){
            cache_builder = new CacheBuilder();
        }
        else{
            return cache_builder.getExpansion();
        }
        this.cacheBuilder = cache_builder;
        List<String> indentations = new LinkedList<>();
        StringBuilder sbIndentation = new StringBuilder();

        StringBuilder sb0 = new StringBuilder();

        sb0.append("*** INTERNAL ERROR ***");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("An internal error was raised with the following message:");
        sb0.append(LINE_SEPARATOR);
        sb0.append(" ");
        sb0.append(buildMessage());
        sb0.append(".");
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("Please submit a defect ticket with the full error trace above on:");
        sb0.append(LINE_SEPARATOR);
        sb0.append(" http://sablecc.org/");

        cache_builder.setExpansion(sb0.toString());
        return sb0.toString();
    }


    @Override
    String build(Context context) {
     return build();
    }
}
{End}

# ============ ex_versions_different ===========

Macro ex_versions_different
    Param
        package_declaration: package_declaration, before_first="\n";
{Body}
{Insert: header}
{package_declaration}
{Insert: import_java_util}

class MUserErrorVersionsDifferent extends Macro{

    public MUserErrorVersionsDifferent(){

    }

    @Override
    void apply(
             InternalsInitializer internalsInitializer){

        internalsInitializer.setUserErrorVersionsDifferent(this);
    }

    public String build(){

        CacheBuilder cache_builder = this.cacheBuilder;

        if(cache_builder == null){
            cache_builder = new CacheBuilder();
        }
        else{
            return cache_builder.getExpansion();
        }
        this.cacheBuilder = cache_builder;
        List<String> indentations = new LinkedList<>();
        StringBuilder sbIndentation = new StringBuilder();

        StringBuilder sb0 = new StringBuilder();

        MObjectMacroUserErrorHead minsert_3 = new MObjectMacroUserErrorHead();

        sb0.append(minsert_3.build(null));
        sb0.append(LINE_SEPARATOR);
        sb0.append(LINE_SEPARATOR);
        sb0.append("The Macros of the child macro must be equal to the Macros of the parent.");

        cache_builder.setExpansion(sb0.toString());
        return sb0.toString();
    }


    @Override
    String build(Context context) {
        return build();
    }
}
{End}
