$comment$
This file is part of SableCC ( http://sablecc.org ).

See the NOTICE file distributed with this work for copyright information.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
$end$

$comment: ========== header ========== $

$text: header $
/* This file was generated by SableCC ( http://sablecc.org ). */
$end: header $

$comment: ========== package ========== $

$macro: package(package) $
$package.$no_eol$
$end: package $

$comment: ========== custom_token ========== $

$macro: custom_token(name) $
$insert: header $

package $no_eol$
$expand: package $
node;

import $no_eol$
$expand: package $
analysis.Analysis;

public class T$name
    extends Token {

  public T$name(
      String text,
      int line,
      int pos) {

        setText(text);
        setLine(line);
        setPos(pos);
  }

  @Override
  public Object clone() {

    return new T$name(getText(), getLine(), getPos());
  }

  public void apply(
      Switch sw) {

    ((Analysis) sw).caseT$name(this);
  }
}
$end: custom_token $

$comment: ========== eof ========== $

$macro: eof $
$insert: header $

package $no_eol$
$expand: package $
node;

import $no_eol$
$expand: package $
analysis.Analysis;

public class EOF
    extends Token {

  public EOF(int line, int pos) {

        setText("");
        setLine(line);
        setPos(pos);
  }

  @Override
  public Object clone() {

    return new EOF(getLine(), getPos());
  }

  public void apply(
      Switch sw) {

    ((Analysis) sw).caseEOF(this);
  }
}
$end: eof $

$comment: ========== lexer ========== $

$macro: lexer $
$insert: header $

package $no_eol$
$expand: package $
lexer;

import $no_eol$
$expand: package $
node.*;

import java.io.*;

public class Lexer {

  private final BufferedReader br;
  private final StringBuilder buffer = new StringBuilder();
  private boolean eof;
  private int line = 1;
  private int pos = 1;
  private boolean last_is_cr;
  private StringBuilder sb;
  private int acceptLine;
  private int acceptPos;
  private int current_sb_length;
  private boolean sb_contains_eof;
$macro: marker_declaration(name) $
  private int marker$name;
$end: marker_declaration $
  private Token token;

$macro: set_marker_declaration(name) $
  void setMarker$name() {
    this.marker$name = this.current_sb_length;
  }
$end: set_marker_declaration $

  public Lexer(Reader reader) {

    this.br = new BufferedReader(reader);
  }

  public Token peek()
      throws LexerException, IOException {

    while(this.token == null) {
      this.token = internalNext();
    };

    return this.token;
  }

  public Token next()
      throws LexerException, IOException {

    Token token = peek();
    this.token = null;
    return token;
  }

  Token internalNext()
      throws LexerException, IOException {

    boolean first = true;

    StringBuilder sb = new StringBuilder();
    State state = S_0.instance;

    while(state.getStateType() == State.StateType.TRANSITION) {
      TransitionState transitionState = (TransitionState) state;

      this.current_sb_length = sb.length();
      transitionState.setMarker(this);

      Symbol symbol;
      if(buffer.length() > 0) {
        char c = buffer.charAt(0);
        buffer.deleteCharAt(0);

        sb.append(c);
        symbol = Symbol.getSymbol(c);
      }
      else if(this.eof) {
        if(sb.length() == 0) {
          return new EOF(this.line, this.pos);
        }
        this.sb_contains_eof = true;
        symbol = Symbol.Symbol_end;
      }
      else {
        int i = br.read();
        if(i == -1) {
          this.eof = true;
          br.close();

          if(sb.length() == 0) {
            return new EOF(this.line, this.pos);
          }
          this.sb_contains_eof = true;
          symbol = Symbol.Symbol_end;
        }
        else {
          char c = (char) i;

          sb.append(c);
          symbol = Symbol.getSymbol(c);
        }
      }

      if(symbol == null) {
        throw new LexerException(sb.charAt(0), this.line, this.pos);
      }

      state = transitionState.getTarget(symbol);

      if(state == null) {
        throw new LexerException(sb.charAt(0), this.line, this.pos);
      }
    }

    FinalState finalState = (FinalState) state;

    this.sb = sb;

    return finalState.getToken(this);
  }

  int getAcceptLine() {
    return this.acceptLine;
  }

  int getAcceptPos() {
    return this.acceptPos;
  }

  private void updateLinePos(String text) {
    if(this.last_is_cr) {
      if(text.length() > 0) {
        if(text.charAt(0) != 10) {
          this.last_is_cr = false;
          this.line++;
          this.pos = 1;
        }
      }
      else if(this.buffer.length() > 0) {
        if(this.buffer.charAt(0) != 10) {
          this.last_is_cr = false;
          this.line++;
          this.pos = 1;
        }
      }
    }

    this.acceptLine = line;
    this.acceptPos = pos;

    for(int i = 0; i < text.length(); i++) {
      char c = text.charAt(i);

      if(c == 10) {
        this.line++;
        this.pos = 1;
      }
      else {
        if(last_is_cr) {
          this.line++;
          this.pos = 2;
        }
        else {
          this.pos++;
        }
      }

      this.last_is_cr = c == 13;
    }
  }

  String accept(int backCount) {
    if(this.sb_contains_eof) {
      this.sb_contains_eof = false;
      backCount--;
    }
    String text = this.sb.toString().substring(0, this.sb.length() - backCount);
    String leftover = this.sb.toString().substring(this.sb.length() - backCount, this.sb.length());
    this.buffer.insert(0, leftover);
    updateLinePos(text);
    return text;
  }

$macro: accept_marker_declaration(name) $
  String acceptWithMarker$name(int backCount) {
    if(this.sb_contains_eof) {
      this.sb_contains_eof = false;
      backCount--;
    }
    String text = this.sb.toString().substring(0, this.marker$name - backCount);
    String leftover = this.sb.toString().substring(this.marker$name - backCount, this.sb.length());
    this.buffer.insert(0, leftover);
    updateLinePos(text);
    return text;
  }
$end: accept_marker_declaration $

}
$end: lexer $

$comment: ========== state ========== $

$macro: state $
$insert: header $

package $no_eol$
$expand: package $
lexer;

abstract class State {

  enum StateType {
    TRANSITION,
    FINAL;
  }

  abstract StateType getStateType();
}
$end: state $

$comment: ========== transition_state ========== $

$macro: transition_state $
$insert: header $

package $no_eol$
$expand: package $
lexer;

abstract class TransitionState
    extends State {

  abstract void setMarker(Lexer lexer);
  abstract State getTarget(Symbol symbol);

  StateType getStateType() {
    return State.StateType.TRANSITION;
  }
}
$end: transition_state $

$comment: ========== final_state ========== $

$macro: final_state $
$insert: header $

package $no_eol$
$expand: package $
lexer;

import $no_eol$
$expand: package $
node.Token;

abstract class FinalState
    extends State {

  abstract Token getToken(Lexer lexer);

  StateType getStateType() {
    return State.StateType.FINAL;
  }
}
$end: final_state $

$comment: ========== transition_state_singleton ========== $

$macro: transition_state_singleton(number) $
$insert: header $

package $no_eol$
$expand: package $
lexer;

class S_$number
    extends TransitionState {

  static final S_$number instance = new S_$number();

  private S_$number() {
  }

$macro: set_marker(name) $
  void setMarker(Lexer lexer) {
    lexer.setMarker$name();
  }
$end: set_marker $
$macro: no_marker $
  void setMarker(Lexer lexer) {
  }
$end: no_marker $

  State getTarget(Symbol symbol) {
    switch(symbol) {
$macro: transition_target(symbol, target) $
    case Symbol_$(symbol):
      return S_$target.instance;
$end: transition_target $
    default:
      return null;
    }
  }

}
$end: transition_state_singleton $

$comment: ========== final_state_singleton ========== $

$macro: final_state_singleton(number,back_count) $
$insert: header $

package $no_eol$
$expand: package $
lexer;

import $no_eol$
$expand: package $
node.*;

class S_$number
    extends FinalState {

  static final S_$number instance = new S_$number();

  private S_$number() {
  }

  Token getToken(Lexer lexer) {
$macro: accept_token_no_marker $
    String text = lexer.accept($back_count);
$end: accept_token_no_marker $
$macro: accept_token_with_marker(marker_name) $
    String text = lexer.acceptWithMarker$marker_name($back_count);
$end: accept_token_with_marker $
    int line = lexer.getAcceptLine();
    int pos = lexer.getAcceptPos();

$macro: accept_normal_token(token_name) $
    return new T$token_name(text, line, pos);
$end: accept_normal_token $
$macro: accept_ignored_token $
    return null;
$end: accept_ignored_token $
  }
}
$end: final_state_singleton $

$comment: ========== symbol ========== $

$macro: symbol $
$insert: header $

package $no_eol$
$expand: package $
lexer;

enum Symbol {
$macro: symbol_declaration(name) $
  Symbol_$name,
$end: symbol_declaration $
  Symbol_end;

  static Symbol getSymbol(char c) {
    switch(c) {
$macro: single_char(bound, name) $
    case $(bound): return Symbol_$name;
$end: single_char $
    default:
$macro: open_interval(name) $
      return Symbol_$name;
$end: open_interval $
$macro: open_left_interval(upper_bound, name) $
      if(c <= $upper_bound) {
        return Symbol_$name;
      }
$end: open_left_interval $
$macro: open_right_interval(lower_bound, name) $
      if(c >= $lower_bound) {
        return Symbol_$name;
      }
$end: open_right_interval $
$macro: interval(lower_bound, upper_bound, name) $
      if(c >= $lower_bound && c <= $upper_bound) {
        return Symbol_$name;
      }
$end: interval $
    }

    return null;
  }
}
$end: symbol $

$comment: ========== lexer_exception ========== $

$macro: lexer_exception $
$insert: header $

package $no_eol$
$expand: package $
lexer;

public class LexerException
    extends Exception {

  private char c;
  private int line;
  private int pos;

  public LexerException(char c, int line, int pos) {
    this.c = c;
    this.line = line;
    this.pos = pos;
  }

  public char getChar() {
    return this.c;
  }

  public int getLine() {
    return this.line;
  }

  public int getPos() {
    return this.pos;
  }

  public String getMessage() {
    return "unrecognized char '" + getChar() + "' on line " + getLine() + ", pos " + getPos();
  }
}
$end: lexer_exception $
